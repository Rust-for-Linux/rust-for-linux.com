<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust for Linux</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Adding support for the Rust language to the Linux kernel">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        
        <link rel="icon" href="Rust-for-Linux.svg">

        <meta property="og:url" content="https://rust-for-linux.com">
        <meta property="og:type" content="website">
        <meta property="og:title" content="Rust for Linux">
        <meta property="og:description" content="Adding support for the Rust language to the Linux kernel">
        <meta property="og:image" content="https://rust-for-linux.com/Rust-for-Linux.svg">
        <script type="application/ld+json">
        {
            "@context": "http://schema.org",
            "@type": "CreativeWork",
            "name": "Rust for Linux",
            "description": "Adding support for the Rust language to the Linux kernel",
            "url": "https://rust-for-linux.com",
            "image": "https://rust-for-linux.com/Rust-for-Linux.svg"
        }
        </script>
        <style>
        #logo {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .rfl-menu-block {
            text-align: center;
            font-size: 1.8rem;
            font-weight: bold;
        }

        .rfl-mono-font {
            font-family: var(--mono-font);
        }

        .rfl-mobile-links {
            display: none;
        }

        @media only screen and (max-width: 1080px) {
            .rfl-mobile-links {
                display: block;
            }
        }

        .chapter li.chapter-item {
            margin-top: 0.2em !important;
            margin-left: 1.5em !important;
        }

        .chapter li.part-title {
            margin-bottom: -0.3em !important;
            margin-top: 1em !important;
        }

        .quote-highlight:target {
            /*
             * `--table-header-bg` is used as an existing color in the themes
             * that is good enough for highlighting the `blockquote`s.
             */
            background-color: var(--table-header-bg);
        }
        </style>
    
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            
        <div class="sidebar-scrollbox">
            <a href="/"><img id="logo" src="Rust-for-Linux.svg" alt="Rust for Linux Logo"></a>
            
            <p class="rfl-menu-block">The project</p>
            <ol class="chapter"><li class="chapter-item"><a href="Contact.html" tabindex="0">Contact</a></li><li class="chapter-item"><a href="Contributing.html" tabindex="0">Contributing</a></li><li class="chapter-item"><a href="Rust-kernel-policy.html" tabindex="0">Rust kernel policy</a></li><li class="chapter-item"><a href="Branches.html" tabindex="0">Branches</a></li><li class="chapter-item"><a href="Rust-reference-drivers.html" tabindex="0">Rust reference drivers</a></li><li class="chapter-item"><a href="Rust-version-policy.html" tabindex="0">Rust version policy</a></li><li class="chapter-item"><a href="Unstable-features.html" tabindex="0">Unstable features</a></li><li class="chapter-item"><a href="Backporting-and-stable-LTS-releases.html" tabindex="0">Backporting and stable/LTS releases</a></li><li class="chapter-item"><a href="Third-party-crates.html" tabindex="0">Third-party crates</a></li><li class="chapter-item"><a href="Out-of-tree-modules.html" tabindex="0">Out-of-tree modules</a></li><li class="chapter-item"><a href="Industry-and-academia-support.html" tabindex="0">Industry and academia support</a></li><li class="chapter-item"><a href="Sponsors.html" tabindex="0">Sponsors</a></li><li class="part-title">Subprojects</li><li class="chapter-item"><a href="klint.html" tabindex="0"><span class="rfl-mono-font">klint</span></a></li><li class="chapter-item"><a href="pin-init.html" tabindex="0"><span class="rfl-mono-font">pin-init</span></a></li><li class="part-title">Tools</li><li class="chapter-item"><a href="Coccinelle-for-Rust.html" tabindex="0">Coccinelle for Rust</a></li><li class="chapter-item"><a href="rustc_codegen_gcc.html" tabindex="0"><span class="rfl-mono-font">rustc_codegen_gcc</span></a></li><li class="chapter-item"><a href="gccrs.html" tabindex="0"><span class="rfl-mono-font">gccrs</span></a></li><li class="part-title">Users — in mainline</li><li class="chapter-item"><a href="AMCC-QT2025-PHY-Driver.html" tabindex="0">AMCC QT2025 PHY Driver</a></li><li class="chapter-item"><a href="Android-Binder-Driver.html" tabindex="0">Android Binder Driver</a></li><li class="chapter-item"><a href="ASIX-PHY-Driver.html" tabindex="0">ASIX PHY Driver</a></li><li class="chapter-item"><a href="DRM-Panic-QR-code-generator.html" tabindex="0">DRM Panic QR code generator</a></li><li class="chapter-item"><a href="Nova-GPU-Driver.html" tabindex="0">Nova GPU Driver</a></li><li class="chapter-item"><a href="Null-Block-Driver.html" tabindex="0">Null Block Driver</a></li><li class="chapter-item"><a href="Tyr-GPU-Driver.html" tabindex="0">Tyr GPU Driver</a></li><li class="part-title">Users — outside mainline</li><li class="chapter-item"><a href="Android-`ashmem`.html" tabindex="0">Android <span class="rfl-mono-font">ashmem</span></a></li><li class="chapter-item"><a href="Apple-AGX-GPU-driver.html" tabindex="0">Apple AGX GPU driver</a></li><li class="chapter-item"><a href="NVMe-driver.html" tabindex="0">NVMe Driver</a></li><li class="chapter-item"><a href="PuzzleFS-filesystem-driver.html" tabindex="0">PuzzleFS filesystem driver</a></li></ol>
        
            <p class="rfl-menu-block">Links</p>
            <ol class="chapter"><li class="part-title">Contact</li><li class="chapter-item"><a href="https://lore.kernel.org/rust-for-linux/" tabindex="0">Lore (mailing list archive)</a></li><li class="chapter-item"><a href="https://rust-for-linux.zulipchat.com" tabindex="0">Zulip (chat)</a></li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux" tabindex="0">GitHub Organization</a></li><li class="part-title">Security</li><li class="chapter-item"><a href="https://docs.kernel.org/process/security-bugs.html" tabindex="0">Report a security bug</a></li><li class="part-title">Issue tracking</li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/linux/issues" tabindex="0">Issues</a></li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/linux/issues/2" tabindex="0">Unstable features</a></li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/linux/contribute" tabindex="0">Good first issues</a></li><li class="part-title">Documentation</li><li class="chapter-item"><a href="https://docs.kernel.org/rust/quick-start.html" tabindex="0">Quick Start guide</a></li><li class="chapter-item"><a href="https://docs.kernel.org/rust/" tabindex="0">Kernel documentation (mainline)</a></li><li class="chapter-item"><a href="https://docs.kernel.org/next/rust/" tabindex="0">Kernel documentation (next)</a></li><li class="chapter-item"><a href="https://rust.docs.kernel.org" tabindex="0">Rust code documentation (mainline)</a></li><li class="chapter-item"><a href="https://rust.docs.kernel.org/next/" tabindex="0">Rust code documentation (next)</a></li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/rust-out-of-tree-module" tabindex="0">Out-of-tree module template</a></li><li class="part-title">Main branches</li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/linux/tree/rust-next" tabindex="0"><span class="rfl-mono-font">rust-next</span></a></li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/linux/tree/rust-fixes" tabindex="0"><span class="rfl-mono-font">rust-fixes</span></a></li><li class="part-title">Subtree branches</li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/linux/tree/alloc-next" tabindex="0"><span class="rfl-mono-font">alloc-next</span></a></li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/linux/tree/pin-init-next" tabindex="0"><span class="rfl-mono-font">pin-init-next</span></a></li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/linux/tree/timekeeping-next" tabindex="0"><span class="rfl-mono-font">timekeeping-next</span></a></li><li class="chapter-item"><a href="https://github.com/Rust-for-Linux/linux/tree/xarray-next" tabindex="0"><span class="rfl-mono-font">xarray-next</span></a></li><li class="part-title">Patchwork</li><li class="chapter-item"><a href="https://patchwork.kernel.org/project/rust-for-linux/list/" tabindex="0">Patchwork</a></li><li class="part-title">Conferences</li><li class="chapter-item"><a href="https://kangrejos.com" tabindex="0">Kangrejos</a></li><li class="chapter-item"><a href="https://lpc.events" tabindex="0">Linux Plumbers Conference (LPC)</a></li><li class="chapter-item"><a href="https://lpc.events/event/19/sessions/223/" tabindex="0">Rust MC at LPC 2025</a></li><li class="chapter-item"><a href="https://lpc.events/event/18/sessions/186/" tabindex="0">Rust MC at LPC 2024</a></li><li class="chapter-item"><a href="https://lpc.events/event/17/sessions/170/" tabindex="0">Rust MC at LPC 2023</a></li><li class="chapter-item"><a href="https://lpc.events/event/16/sessions/150/" tabindex="0">Rust MC at LPC 2022</a></li><li class="part-title">LWN</li><li class="chapter-item"><a href="https://lwn.net/Kernel/Index/#Development_tools-Rust" tabindex="0">Rust index</a></li><li class="chapter-item"><a href="https://lwn.net/Archives/ConferenceIndex/#Kangrejos" tabindex="0">Kangrejos index</a></li><li class="part-title">Tools and toolchains</li><li class="chapter-item"><a href="https://kernel.org/pub/tools/llvm/rust/" tabindex="0">kernel.org prebuilt LLVM+Rust</a></li><li class="chapter-item"><a href="https://github.com/rust-lang/rustc_codegen_gcc" tabindex="0"><span class="rfl-mono-font">rustc_codegen_gcc</span></a></li><li class="chapter-item"><a href="https://rust-gcc.github.io" tabindex="0">Rust GCC</a></li><li class="chapter-item"><a href="https://github.com/acmel/dwarves" tabindex="0"><span class="rfl-mono-font">pahole</span></a></li><li class="part-title">Other trees</li><li class="chapter-item"><a href="https://git.kernel.org/linus/" tabindex="0">Linus' tree</a></li><li class="chapter-item"><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/" tabindex="0">Stable tree</a></li><li class="chapter-item"><a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/" tabindex="0"><span class="rfl-mono-font">linux-next</span> tree</a></li><li class="part-title">Other resources</li><li class="chapter-item"><a href="https://elixir.bootlin.com/linux/latest/source/rust" tabindex="0">Bootlin's Elixir</a></li><li class="chapter-item"><a href="https://godbolt.org/z/a55MozK6s" tabindex="0">Compiler Explorer</a></li><li class="chapter-item"><a href="https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021" tabindex="0">Rust Playground</a></li><li class="chapter-item"><a href="https://doc.rust-lang.org/core/" tabindex="0">Rust <span class="rfl-mono-font">core</span> docs</a></li></ol>
        
        </div>
    
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for Linux</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Rust-for-Linux/rust-for-linux.com" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-for-linux"><a class="header" href="#rust-for-linux">Rust for Linux</a></h1>
<p>Rust for Linux is the project adding support for the Rust language to the Linux kernel.</p>
<p>This website is intended as a hub of links, documentation and resources related to the project.</p>

        <h2><a class="header" href="#the-project">The project</a></h2>
        <ul><li><a href="Contact.html" tabindex="0">Contact</a></li><li><a href="Contributing.html" tabindex="0">Contributing</a></li><li><a href="Rust-kernel-policy.html" tabindex="0">Rust kernel policy</a></li><li><a href="Branches.html" tabindex="0">Branches</a></li><li><a href="Rust-reference-drivers.html" tabindex="0">Rust reference drivers</a></li><li><a href="Rust-version-policy.html" tabindex="0">Rust version policy</a></li><li><a href="Unstable-features.html" tabindex="0">Unstable features</a></li><li><a href="Backporting-and-stable-LTS-releases.html" tabindex="0">Backporting and stable/LTS releases</a></li><li><a href="Third-party-crates.html" tabindex="0">Third-party crates</a></li><li><a href="Out-of-tree-modules.html" tabindex="0">Out-of-tree modules</a></li><li><a href="Industry-and-academia-support.html" tabindex="0">Industry and academia support</a></li><li><a href="Sponsors.html" tabindex="0">Sponsors</a></li></ul>
<h3>Subprojects</h3>
<ul><li><a href="klint.html" tabindex="0"><span class="rfl-mono-font">klint</span></a></li><li><a href="pin-init.html" tabindex="0"><span class="rfl-mono-font">pin-init</span></a></li></ul>
<h3>Tools</h3>
<ul><li><a href="Coccinelle-for-Rust.html" tabindex="0">Coccinelle for Rust</a></li><li><a href="rustc_codegen_gcc.html" tabindex="0"><span class="rfl-mono-font">rustc_codegen_gcc</span></a></li><li><a href="gccrs.html" tabindex="0"><span class="rfl-mono-font">gccrs</span></a></li></ul>
<h3>Users — in mainline</h3>
<ul><li><a href="AMCC-QT2025-PHY-Driver.html" tabindex="0">AMCC QT2025 PHY Driver</a></li><li><a href="Android-Binder-Driver.html" tabindex="0">Android Binder Driver</a></li><li><a href="ASIX-PHY-Driver.html" tabindex="0">ASIX PHY Driver</a></li><li><a href="DRM-Panic-QR-code-generator.html" tabindex="0">DRM Panic QR code generator</a></li><li><a href="Nova-GPU-Driver.html" tabindex="0">Nova GPU Driver</a></li><li><a href="Null-Block-Driver.html" tabindex="0">Null Block Driver</a></li><li><a href="Tyr-GPU-Driver.html" tabindex="0">Tyr GPU Driver</a></li></ul>
<h3>Users — outside mainline</h3>
<ul><li><a href="Android-`ashmem`.html" tabindex="0">Android <span class="rfl-mono-font">ashmem</span></a></li><li><a href="Apple-AGX-GPU-driver.html" tabindex="0">Apple AGX GPU driver</a></li><li><a href="NVMe-driver.html" tabindex="0">NVMe Driver</a></li><li><a href="PuzzleFS-filesystem-driver.html" tabindex="0">PuzzleFS filesystem driver</a></li></ul>

        <div class="rfl-mobile-links">
            <h2><a class="header" href="#links">Links</a></h2>
            <h3>Contact</h3>
<ul><li><a href="https://lore.kernel.org/rust-for-linux/" tabindex="0">Lore (mailing list archive)</a></li><li><a href="https://rust-for-linux.zulipchat.com" tabindex="0">Zulip (chat)</a></li><li><a href="https://github.com/Rust-for-Linux" tabindex="0">GitHub Organization</a></li></ul>
<h3>Security</h3>
<ul><li><a href="https://docs.kernel.org/process/security-bugs.html" tabindex="0">Report a security bug</a></li></ul>
<h3>Issue tracking</h3>
<ul><li><a href="https://github.com/Rust-for-Linux/linux/issues" tabindex="0">Issues</a></li><li><a href="https://github.com/Rust-for-Linux/linux/issues/2" tabindex="0">Unstable features</a></li><li><a href="https://github.com/Rust-for-Linux/linux/contribute" tabindex="0">Good first issues</a></li></ul>
<h3>Documentation</h3>
<ul><li><a href="https://docs.kernel.org/rust/quick-start.html" tabindex="0">Quick Start guide</a></li><li><a href="https://docs.kernel.org/rust/" tabindex="0">Kernel documentation (mainline)</a></li><li><a href="https://docs.kernel.org/next/rust/" tabindex="0">Kernel documentation (next)</a></li><li><a href="https://rust.docs.kernel.org" tabindex="0">Rust code documentation (mainline)</a></li><li><a href="https://rust.docs.kernel.org/next/" tabindex="0">Rust code documentation (next)</a></li><li><a href="https://github.com/Rust-for-Linux/rust-out-of-tree-module" tabindex="0">Out-of-tree module template</a></li></ul>
<h3>Main branches</h3>
<ul><li><a href="https://github.com/Rust-for-Linux/linux/tree/rust-next" tabindex="0"><span class="rfl-mono-font">rust-next</span></a></li><li><a href="https://github.com/Rust-for-Linux/linux/tree/rust-fixes" tabindex="0"><span class="rfl-mono-font">rust-fixes</span></a></li></ul>
<h3>Subtree branches</h3>
<ul><li><a href="https://github.com/Rust-for-Linux/linux/tree/alloc-next" tabindex="0"><span class="rfl-mono-font">alloc-next</span></a></li><li><a href="https://github.com/Rust-for-Linux/linux/tree/pin-init-next" tabindex="0"><span class="rfl-mono-font">pin-init-next</span></a></li><li><a href="https://github.com/Rust-for-Linux/linux/tree/timekeeping-next" tabindex="0"><span class="rfl-mono-font">timekeeping-next</span></a></li><li><a href="https://github.com/Rust-for-Linux/linux/tree/xarray-next" tabindex="0"><span class="rfl-mono-font">xarray-next</span></a></li></ul>
<h3>Patchwork</h3>
<ul><li><a href="https://patchwork.kernel.org/project/rust-for-linux/list/" tabindex="0">Patchwork</a></li></ul>
<h3>Conferences</h3>
<ul><li><a href="https://kangrejos.com" tabindex="0">Kangrejos</a></li><li><a href="https://lpc.events" tabindex="0">Linux Plumbers Conference (LPC)</a></li><li><a href="https://lpc.events/event/19/sessions/223/" tabindex="0">Rust MC at LPC 2025</a></li><li><a href="https://lpc.events/event/18/sessions/186/" tabindex="0">Rust MC at LPC 2024</a></li><li><a href="https://lpc.events/event/17/sessions/170/" tabindex="0">Rust MC at LPC 2023</a></li><li><a href="https://lpc.events/event/16/sessions/150/" tabindex="0">Rust MC at LPC 2022</a></li></ul>
<h3>LWN</h3>
<ul><li><a href="https://lwn.net/Kernel/Index/#Development_tools-Rust" tabindex="0">Rust index</a></li><li><a href="https://lwn.net/Archives/ConferenceIndex/#Kangrejos" tabindex="0">Kangrejos index</a></li></ul>
<h3>Tools and toolchains</h3>
<ul><li><a href="https://kernel.org/pub/tools/llvm/rust/" tabindex="0">kernel.org prebuilt LLVM+Rust</a></li><li><a href="https://github.com/rust-lang/rustc_codegen_gcc" tabindex="0"><span class="rfl-mono-font">rustc_codegen_gcc</span></a></li><li><a href="https://rust-gcc.github.io" tabindex="0">Rust GCC</a></li><li><a href="https://github.com/acmel/dwarves" tabindex="0"><span class="rfl-mono-font">pahole</span></a></li></ul>
<h3>Other trees</h3>
<ul><li><a href="https://git.kernel.org/linus/" tabindex="0">Linus' tree</a></li><li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/" tabindex="0">Stable tree</a></li><li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/" tabindex="0"><span class="rfl-mono-font">linux-next</span> tree</a></li></ul>
<h3>Other resources</h3>
<ul><li><a href="https://elixir.bootlin.com/linux/latest/source/rust" tabindex="0">Bootlin's Elixir</a></li><li><a href="https://godbolt.org/z/a55MozK6s" tabindex="0">Compiler Explorer</a></li><li><a href="https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021" tabindex="0">Rust Playground</a></li><li><a href="https://doc.rust-lang.org/core/" tabindex="0">Rust <span class="rfl-mono-font">core</span> docs</a></li></ul>

        </div>
    
<div style="break-before: page; page-break-before: always;"></div><h1 id="contact"><a class="header" href="#contact">Contact</a></h1>
<h2 id="mailing-list"><a class="header" href="#mailing-list">Mailing list</a></h2>
<p>The <a href="mailto:rust-for-linux@vger.kernel.org"><code>rust-for-linux@vger.kernel.org</code></a> mailing list is primarily meant for patch submission and reviewing, as well as announcements and technical discussions on mainline development:</p>
<ul>
<li><a href="mailto:rust-for-linux+subscribe@vger.kernel.org">Subscription link</a>.</li>
<li><a href="https://subspace.kernel.org/subscribing.html">Subscription instructions</a>.</li>
<li><a href="https://lore.kernel.org/rust-for-linux/">Lore (archive)</a>.</li>
</ul>
<p>Please read the <a href="https://subspace.kernel.org/etiquette.html">Mailing list etiquette</a> document if it is the first time you send an email to a Linux kernel mailing list.</p>
<p>For general questions, please use the Zulip chat instead.</p>
<h2 id="zulip-chat"><a class="header" href="#zulip-chat">Zulip chat</a></h2>
<p>For chat, we use <a href="https://rust-for-linux.zulipchat.com">Zulip</a>.</p>
<ul>
<li><a href="https://rust-for-linux.zulipchat.com/register/">Registration link</a>.</li>
</ul>
<p>Please feel free to use it for general questions, discussion, help, feedback, etc.</p>
<h2 id="open-meeting"><a class="header" href="#open-meeting">Open Meeting</a></h2>
<p>Everybody is welcome to join our <a href="https://meet.google.com/vii-meij-xpw">Open Meeting</a>.</p>
<p>It takes place once every kernel cycle, the first Wednesday after <code>-rc1</code> is tagged, at 20:00 CET or CEST (i.e. CET at &quot;summer time&quot;).</p>
<h2 id="github-issue-tracker"><a class="header" href="#github-issue-tracker">GitHub issue tracker</a></h2>
<p><a href="https://github.com/Rust-for-Linux/linux/issues">GitHub</a> is used for issue reporting, tracking and discussion.</p>
<ul>
<li><a href="https://github.com/Rust-for-Linux/linux/issues/new/choose">Submit a new issue</a>.</li>
<li><a href="https://github.com/Rust-for-Linux/linux/issues/2">Unstable features list</a>.</li>
<li><a href="https://github.com/Rust-for-Linux/linux/contribute">Good first issues</a>.</li>
</ul>
<p>Please do <em><strong>not</strong></em> report security bugs in the GitHub issue tracker. Instead, please read the <a href="https://docs.kernel.org/process/security-bugs.html">Security bugs</a> page in the kernel documentation.</p>
<p>For general questions, please use the Zulip chat instead.</p>
<h2 id="email"><a class="header" href="#email">Email</a></h2>
<p>For other matters, please feel free to contact the <a href="https://docs.kernel.org/process/maintainers.html#rust">maintainers</a> via email.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>There are many ways to contribute to Rust for Linux. One way is to contribute to the kernel itself — the rest of this page focuses on that. But there are other ways as well:</p>
<ul>
<li>
<p>In Rust:</p>
<ul>
<li>
<p>Helping to stabilize <a href="Unstable-features.html">unstable features</a> the kernel requires.</p>
</li>
<li>
<p>Adding support for features we would like in the kernel: in the language, in the standard library, in the compiler, in <code>rustdoc</code>, in Clippy, in <code>bindgen</code>... Please see the various <a href="https://github.com/Rust-for-Linux/linux/issues/2">&quot;wanted features &amp; bugfixes&quot; lists</a> for each topic.</p>
</li>
</ul>
</li>
<li>
<p>Contributing to the subprojects: <a href="klint.html"><code>klint</code></a> and <a href="pin-init.html"><code>pin-init</code></a>.</p>
</li>
<li>
<p>Contributing to the <a href="Coccinelle-for-Rust.html">Coccinelle for Rust</a> project.</p>
</li>
<li>
<p>Contributing to the <a href="rustc_codegen_gcc.html"><code>rustc_codegen_gcc</code></a> project, which will be used by the kernel for GCC builds.</p>
</li>
<li>
<p>Contributing to the <a href="gccrs.html"><code>gccrs</code></a> project, which eventually will provide a second toolchain for GCC builds.</p>
</li>
<li>
<p>Improve support for Rust in <a href="https://github.com/acmel/dwarves"><code>pahole</code></a>.</p>
</li>
</ul>
<h2 id="the-kernel-development-process"><a class="header" href="#the-kernel-development-process">The kernel development process</a></h2>
<p>The Rust support is part of the Linux kernel, and thus contributing works the same way as for the latter. That implies, among other things:</p>
<ul>
<li>
<p>A patch-based workflow is used.</p>
</li>
<li>
<p>Reviews take place in the different mailing lists of the kernel.</p>
</li>
<li>
<p>Contributions are signed under the <a href="https://docs.kernel.org/process/submitting-patches.html#developer-s-certificate-of-origin-1-1">Developer's Certificate of Origin</a>.</p>
</li>
</ul>
<p>To learn more about the kernel development process, please read the documentation under <a href="https://docs.kernel.org/process/"><code>Documentation/process</code></a>. In particular, please make sure to read <a href="https://docs.kernel.org/process/submitting-patches.html"><code>submitting-patches.rst</code></a>.</p>
<p>In addition, it may be a good idea to contribute a small cleanup or fix somewhere in the kernel (not necessarily to Rust code), in order to get accustomed to the patch-based workflow. From time to time we add <a href="https://github.com/Rust-for-Linux/linux/contribute">&quot;good first issues&quot;</a> to our GitHub issue tracker for that purpose.</p>
<h2 id="ways-to-contribute"><a class="header" href="#ways-to-contribute">Ways to contribute</a></h2>
<p>There are many ways to contribute to the Rust support in the kernel:</p>
<ul>
<li>
<p>Submitting changes, of course, whether it is new code or improvements to existing code. Please see the details below on this option.</p>
</li>
<li>
<p>Reviewing patches, especially if you have experience with unsafe Rust and have an eye to spot unsoundness issues or with Rust API design in general. Reviewers can get credited within commits messages via the <code>Reviewed-by</code> tag.</p>
</li>
<li>
<p>Testing patches. Like reviewing, running meaningful testing increases the confidence that the patch is OK. Testers can get credited within commits messages via the <code>Tested-by</code> tag.</p>
</li>
<li>
<p>Reporting issues you find. Reporters can get credited within commits messages via the <code>Reported-by</code> tag.</p>
</li>
<li>
<p>Suggesting improvements. Good ideas that end up being implemented can get credited within commit messages via the <code>Suggested-by</code> tag.</p>
</li>
<li>
<p>Helping others on Zulip. For instance, getting them started with the Rust support in the kernel.</p>
</li>
</ul>
<h2 id="getting-started-with-rust-kernel-development"><a class="header" href="#getting-started-with-rust-kernel-development">Getting started with Rust kernel development</a></h2>
<p>Please read the documentation under <a href="https://docs.kernel.org/rust/"><code>Documentation/rust</code></a>. In particular, the <a href="https://docs.kernel.org/rust/quick-start.html">Quick Start guide</a>.</p>
<p>Reading the rest of this website is also recommended.</p>
<h2 id="the-rust-subsystem"><a class="header" href="#the-rust-subsystem">The Rust subsystem</a></h2>
<p>The Rust subsystem takes care of the core Rust abstractions as well as the general infrastructure for Rust in the kernel. It is a bit special in that it potentially intersects with every other subsystem in the kernel, especially in the beginning of the Rust support in the kernel.</p>
<p>For this reason, early on, there are a few extra notes to have in mind when contributing Rust code to the kernel.</p>
<h3 id="submitting-changes-to-existing-code"><a class="header" href="#submitting-changes-to-existing-code">Submitting changes to existing code</a></h3>
<p>All patches containing Rust code should be sent to both the maintainers/reviewers/mailing lists of the relevant kernel subsystem they touch as well as the Rust one.</p>
<p>This applies even if the files that the patch modifies are all under <code>rust/</code> (e.g. currently all abstractions live under <code>rust/</code>, but the plan is to change this in the future as Rust grows in the kernel) and the files are referenced by the <code>MAINTAINERS</code> entry of the relevant subsystem. Scripts like <code>scripts/get_maintainers.pl</code> may not provide the complete list.</p>
<p>The goal with this procedure is that everybody interested in Rust can follow what is going on with Rust in the entire kernel in the early stages, to avoid duplicate work, and to make it easier for everybody to coordinate.</p>
<p>For instance, if a patch modifies <code>rust/kernel/time.rs</code>, then the patch should be sent to both &quot;TIMEKEEPING&quot; and &quot;RUST&quot;.</p>
<p>Ideally, the maintainers of the particular subsystem will take the changes through their tree, instead of going through the Rust one.</p>
<p>Please make sure your code is properly documented, that the code compiles warning-free under <code>CLIPPY=1</code>, that the code documentation tests pass and that the code is formatted.</p>
<h3 id="submitting-new-abstractions-and-modules"><a class="header" href="#submitting-new-abstractions-and-modules">Submitting new abstractions and modules</a></h3>
<p>For new abstractions and modules, and especially for those that require new kernel subsystems/maintainers to be involved, please follow the approach outlined here.</p>
<ul>
<li>
<p>Kernel maintainers and developers interested in using Rust should take the lead in developing missing abstractions/modules for the subsystems they need.</p>
</li>
<li>
<p>Part of the work may be already done or in the process of being upstreamed, thus please first check the <a href="https://lore.kernel.org/rust-for-linux/">mailing list archive</a> as well as the <a href="https://github.com/Rust-for-Linux/linux/pulls">PRs submitted to GitHub</a>. It is also a good idea to ask on our <a href="https://rust-for-linux.zulipchat.com">Zulip chat</a>.</p>
</li>
<li>
<p>As early as possible, please get in touch with the maintainers of the relevant subsystem in order to make them aware of the work you are doing or planning to do. That way, they can give you input and feedback on the process. Please feel free to Cc the Rust maintainers too.</p>
</li>
<li>
<p>Consider whether a <a href="Rust-reference-drivers.html">Rust reference driver</a> could be a good idea to bootstrap Rust into the subsystem.</p>
</li>
<li>
<p>When you are getting closer to patch submission, please consider sending an RFC series first, especially if it is a major contribution, or if it is a long patch series, or if you require a lot of prerequisite patches (e.g. for abstractions of other subsystems) that are not yet upstreamed.</p>
<p>The RFC can be based on top of a branch placed somewhere else that contains the prerequisite patches, so that the RFC patches themselves do not cover those, and therefore is focused on the parts that the maintainers will eventually review.</p>
<p>This way, you can get early design feedback before the actual patch submission later, and the discussion is focused on the given subsystem (rather than the prerequisites).</p>
</li>
<li>
<p>In general, the kernel does not allow to integrate code without users, but exceptions can potentially be made for Rust code to simplify the upstreaming process early on. That is, upstreaming some dependencies first so that it is easier to upstream expected in-tree users later on. However, note that this is not meant to be a way to justify upstreaming APIs that do not have agreed upon in-tree users. In particular, <a href="Out-of-tree-modules.html">out-of-tree modules</a> do not constitute a user in this context.</p>
<p>Please contact the Rust maintainers for help, especially if you find yourself with a lot of dependencies or patches for unrelated subsystems.</p>
</li>
</ul>
<h3 id="submit-checklist-addendum"><a class="header" href="#submit-checklist-addendum">Submit checklist addendum</a></h3>
<p>The following items apply to every patch in a series. That is, in general, each commit should be clean, not just the end state.</p>
<ul>
<li>
<p>Please keep the code Clippy-clean by compiling with <code>CLIPPY=1</code>.</p>
</li>
<li>
<p>Please format the code by running the <code>rustfmt</code> target. Please see the <a href="https://docs.kernel.org/rust/coding-guidelines.html#style-formatting">style guidelines</a> as well.</p>
</li>
<li>
<p>When submitting changes to Rust code documentation, please render them using the <code>rustdoc</code> target and ensure the result looks as expected. The Rust code documentation gets rendered at <a href="https://rust.docs.kernel.org">https://rust.docs.kernel.org</a>.</p>
</li>
<li>
<p>When submitting changes to tests, including <code>#[test]</code>s, Kselftests and examples inside Rust code documentation (i.e. &quot;doctests&quot;, which are transformed into KUnit tests), please <a href="https://docs.kernel.org/rust/testing.html">test them</a>.</p>
</li>
<li>
<p>When submitting changes to the Rust folder of the kernel documentation (i.e. <code>Documentation/rust/</code>), which are written in reStructuredText and handled by Sphinx, please <a href="https://docs.kernel.org/doc-guide/sphinx.html">render them</a> (typically using the <code>htmldocs</code> target) to ensure there are no warnings and that the result looks as expected. The Rust kernel documentation gets rendered at <a href="https://docs.kernel.org/rust/">https://docs.kernel.org/rust/</a>.</p>
</li>
<li>
<p>Ideally, please check your changes with both the latest stable Rust compiler as well as the minimum supported version (<code>scripts/min-tool-version.sh rustc</code>), including Clippy.</p>
</li>
<li>
<p>Please run your patch through the <code>scripts/checkpatch.pl</code> script. In particular, the <code>--codespell</code> option is useful to check patches for typos.</p>
</li>
</ul>
<h3 id="key-cycle-dates"><a class="header" href="#key-cycle-dates">Key cycle dates</a></h3>
<ul>
<li>
<p>Patches can be sent anytime.</p>
</li>
<li>
<p>We aim to send early PRs to Linus, to have patches for at least a week in linux-next and to give patches at least a week of review time.</p>
<p>Therefore, in general, the last version of a patch series with new features (i.e. aimed at the next merge window) should arrive before -rc5.</p>
</li>
</ul>
<h2 id="submitting-patches"><a class="header" href="#submitting-patches">Submitting patches</a></h2>
<p>If you are using a CLI tool like <a href="https://git-scm.com/docs/git-send-email"><code>git-send-email</code></a> or <a href="https://b4.docs.kernel.org"><code>b4</code></a>, then you may find the following commands useful for generating the options needed for submitting patches to the Rust subsystem:</p>
<pre><code class="language-sh">awk '/^RUST$/,/^$/' MAINTAINERS | grep '^M:'    | cut -f2- | xargs -IP echo --to \'P\' \\
awk '/^RUST$/,/^$/' MAINTAINERS | grep '^[RL]:' | cut -f2- | xargs -IP echo --cc \'P\' \\
</code></pre>
<p>This list includes the maintainers (<code>M:</code>), reviewers (<code>R:</code>) and mailing list (<code>L:</code>) of the <a href="https://docs.kernel.org/process/maintainers.html#rust">&quot;RUST&quot; subsystem</a> in the <code>MAINTAINERS</code> file.</p>
<p>However, please keep in mind that this does not cover additional subsystems that you may need to submit your patches to, as explained in the other sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-kernel-policy"><a class="header" href="#rust-kernel-policy">Rust kernel policy</a></h1>
<p>There has been a fair amount of confusion about what the kernel policies around Rust are, who maintains what and so on.</p>
<p>This document tries to clarify some of these points with what, to the best of our knowledge, is the current status.</p>
<p>Like most things in the kernel, these points are not hard rules and can change over time depending on the situation and what key maintainers and the kernel community discuss.</p>
<h2 id="how-is-rust-introduced-in-a-subsystem"><a class="header" href="#how-is-rust-introduced-in-a-subsystem">How is Rust introduced in a subsystem?</a></h2>
<p>Like for many other things in the kernel, it is up to each subsystem how they want to deal with Rust.</p>
<p>The goal has always been to get maintainers involved progressively, because the effort does not scale otherwise.</p>
<p>Therefore, different subsystems have taken different approaches so far:</p>
<ul>
<li>
<p>Some subsystems prefer to actively drive the Rust effort themselves, taking patches, fixing issues, etc. This may allow them the chance to learn Rust in the process.</p>
</li>
<li>
<p>Some subsystems prefer to get a new co-maintainer, sub-maintainer, reviewer, etc. to split the workload, letting them take care of the Rust side. Some may want to do so in their existing <code>MAINTAINERS</code> entry; others may prefer a new entry dedicated to that. Some may want to use the same trees to land the patches. Some may want PRs from their Rust sub-maintainer. And so on and so forth.</p>
</li>
<li>
<p>Some subsystems may decide they do not want to have Rust code for the time being, typically for bandwidth reasons. This is fine and expected.</p>
</li>
</ul>
<p>Now, in the Kernel Maintainers Summit 2022, we asked for flexibility when the time comes that a major user of Rust in the kernel requires key APIs for which the maintainer may not be able to maintain Rust abstractions for it. This is the needed counterpart to the ability of maintainers to decide whether they want to allow Rust or not.</p>
<h2 id="do-kernel-maintainers-support-rust-in-the-kernel"><a class="header" href="#do-kernel-maintainers-support-rust-in-the-kernel">Do kernel maintainers support Rust in the kernel?</a></h2>
<p>Yes, there are key kernel maintainers that support Rust in the kernel.</p>
<p>Please see the quotes given by kernel maintainers for the <a href="https://fosdem.org/2025/events/attachments/fosdem-2025-6507-rust-for-linux/slides/237976/2025-02-0_iwSaMYM.pdf">FOSDEM 2025 Rust for Linux keynote</a>, slides 45-85.</p>
<h2 id="who-maintains-rust-code-in-the-kernel"><a class="header" href="#who-maintains-rust-code-in-the-kernel">Who maintains Rust code in the kernel?</a></h2>
<p>The usual kernel policy applies. That is, whoever is the listed maintainer.</p>
<p>The &quot;RUST&quot; subsystem maintains certain core facilities as well as some APIs that do not have other maintainers. However, it does not maintain all the Rust code in the kernel — it would not scale.</p>
<p>Nevertheless, the team can be approached for help if needed — indeed, the intention has always been to build a mixed team of people that could help across the kernel to bootstrap Rust.</p>
<p>Eventually, the &quot;RUST&quot; subsystem could also act as &quot;fallback maintainers&quot; for Rust code too, similar to how akpm serves as a last resort maintainer.</p>
<h2 id="who-is-responsible-if-a-c-change-breaks-a-build-with-rust-enabled"><a class="header" href="#who-is-responsible-if-a-c-change-breaks-a-build-with-rust-enabled">Who is responsible if a C change breaks a build with Rust enabled?</a></h2>
<p>The usual kernel policy applies. So, by default, changes should not be introduced if they are known to break the build, including Rust.</p>
<p>However, exceptionally, for Rust, a subsystem may allow to temporarily break Rust code. The intention is to facilitate friendly adoption of Rust in a subsystem without introducing a burden to existing maintainers who may be working on urgent fixes for the C side. The breakage should nevertheless be fixed as soon as possible, ideally before the breakage reaches Linus.</p>
<p>For instance, this approach was chosen by the block layer — they called it &quot;stage 1&quot; in their <a href="https://lore.kernel.org/all/593a98c9-baaa-496b-a9a7-c886463722e1@kernel.dk/">Rust integration plan</a>.</p>
<p>We believe this approach is reasonable as long as the kernel does not have way too many subsystems doing that (because otherwise it would be very hard to build e.g. linux-next).</p>
<h2 id="should-maintainers-treat-rust-code-up-to-the-same-standards"><a class="header" href="#should-maintainers-treat-rust-code-up-to-the-same-standards">Should maintainers treat Rust code up to the same standards?</a></h2>
<p>Ideally, and eventually, yes. However, when they are starting out, not necessarily.</p>
<p>The intention is that maintainers are not pressured to reject Rust, even if they wanted to try it, just because they may feel they will not be able to provide timely fixes and so on the same way they do for C.</p>
<p>Thus, depending on the subsystem, Rust may be seen as a new thing, and new things can break. In fact, ideally it should be fun for maintainers to try Rust.</p>
<h2 id="didnt-you-promise-rust-wouldnt-be-extra-work-for-maintainers"><a class="header" href="#didnt-you-promise-rust-wouldnt-be-extra-work-for-maintainers">Didn't you promise Rust wouldn't be extra work for maintainers?</a></h2>
<p>No, we did not. Since the very beginning, we acknowledged the costs and risks a second language introduces. However, we believe the advantages of introducing Rust in the Linux kernel outweigh those costs.</p>
<p>Please see the <a href="https://lore.kernel.org/lkml/20210414184604.23473-1-ojeda@kernel.org/">original RFC</a>.</p>
<h2 id="years-have-passed-have-you-reevaluated-the-tradeoffs-mentioned-in-the-original-rfc"><a class="header" href="#years-have-passed-have-you-reevaluated-the-tradeoffs-mentioned-in-the-original-rfc">Years have passed, have you reevaluated the tradeoffs mentioned in the original RFC?</a></h2>
<p>As years have passed, the advantages mentioned in the RFC have become more evident, and part of the initial costs have already been paid.</p>
<p>For instance, within the kernel, successful complex Rust drivers have been written and improvements to the C side were implemented. Outside the kernel, there is nowadays increased industry pressure to move to memory safe languages than when we started years ago.</p>
<p>On the costs side, a lot of the required setup work within the kernel is in place, most Rust language features we used were stabilized, Rust compiler features were implemented, other projects improved their support for Rust as well (e.g. <code>bindgen</code>, Coccinelle for Rust, <code>pahole</code>, GCC, <code>rustc_codegen_gcc</code>...), and so on.</p>
<h2 id="are-duplicated-crust-drivers-allowed"><a class="header" href="#are-duplicated-crust-drivers-allowed">Are duplicated C/Rust drivers allowed?</a></h2>
<p>The usual kernel policy applies. So, by default, no.</p>
<p>However, subsystems may decide to allow it, temporarily, to get Rust bootstrapped — please see <a href="Rust-reference-drivers.html">Rust reference drivers</a>.</p>
<h2 id="is-rust-for-linux-driven-by-the-rust-community"><a class="header" href="#is-rust-for-linux-driven-by-the-rust-community">Is Rust for Linux driven by the &quot;Rust community&quot;?</a></h2>
<p>No, the people involved around Rust for Linux come from different backgrounds and organizations. Some are kernel maintainers, some are Rust experts. Some are hobbyists, some are employees at large corporations.</p>
<p>In particular, it is not an effort driven by the Rust Project nor the Rust Foundation. In fact, Rust for Linux was founded by a Linux kernel maintainer as a hobby.</p>
<h2 id="are-companies-involved-in-rust-in-the-kernel"><a class="header" href="#are-companies-involved-in-rust-in-the-kernel">Are companies involved in Rust in the kernel?</a></h2>
<p>Yes, at the time of writing, there are at least 6+ FTEs publicly working on Rust for Linux or its users across several major companies. Privately, there are more.</p>
<p>Please see our <a href="Industry-and-academia-support.html">Industry and academia support</a> page as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="branches"><a class="header" href="#branches">Branches</a></h1>
<h2 id="main-branches"><a class="header" href="#main-branches">Main branches</a></h2>
<p>Currently we maintain the following main branches. There are, of course, other trees that also land Rust code via their own trees. For the latest information, please check the <a href="https://docs.kernel.org/process/maintainers.html"><code>MAINTAINERS</code> file</a>.</p>
<p>They are all part of <a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/"><code>linux-next</code></a>.</p>
<h3 id="rust-next"><a class="header" href="#rust-next"><code>rust-next</code></a></h3>
<p><a href="https://github.com/Rust-for-Linux/linux/tree/rust-next"><code>rust-next</code></a> is the branch that contains new Rust features to be submitted during the next merge window of the Linux kernel. That is, it is the development branch of the <a href="https://docs.kernel.org/process/maintainers.html#rust">&quot;RUST&quot; entry</a> in the <code>MAINTAINERS</code> file.</p>
<p>Changes to this branch land via patches sent to the mailing list, or through pulls of one of the subtrees (please see below).</p>
<p>It is part of <a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/"><code>linux-next</code></a>.</p>
<h3 id="rust-fixes"><a class="header" href="#rust-fixes"><code>rust-fixes</code></a></h3>
<p><a href="https://github.com/Rust-for-Linux/linux/tree/rust-fixes"><code>rust-fixes</code></a> is the branch that contains Rust fixes for the current cycle of the Linux kernel.</p>
<p>Changes to this branch land via patches sent to the mailing list.</p>
<p>It is part of <a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/"><code>linux-next</code></a>.</p>
<h2 id="subtree-branches"><a class="header" href="#subtree-branches">Subtree branches</a></h2>
<p>These are the branches of the Rust subtrees that land into mainline via the main <code>rust-next</code> branch.</p>
<p>Changes to these branches land via patches sent to the mailing list.</p>
<p>They are all part of <a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/"><code>linux-next</code></a>. Fixes for these branches land through <code>rust-fixes</code>.</p>
<h3 id="alloc-next"><a class="header" href="#alloc-next"><code>alloc-next</code></a></h3>
<p><a href="https://github.com/Rust-for-Linux/linux/tree/alloc-next"><code>alloc-next</code></a> is the branch for the <a href="https://docs.kernel.org/process/maintainers.html#rust-alloc">&quot;RUST [ALLOC]&quot; entry</a> and the <a href="https://docs.kernel.org/process/maintainers.html#dma-mapping-helpers-device-driver-api-rust">&quot;DMA MAPPING HELPERS DEVICE DRIVER API [RUST]&quot; entry</a> in the <code>MAINTAINERS</code> file.</p>
<h3 id="pin-init-next"><a class="header" href="#pin-init-next"><code>pin-init-next</code></a></h3>
<p><a href="https://github.com/Rust-for-Linux/linux/tree/pin-init-next"><code>pin-init-next</code></a> is the branch for the <a href="https://docs.kernel.org/process/maintainers.html#rust-pin-init">&quot;RUST [PIN-INIT]&quot; entry</a> in the <code>MAINTAINERS</code> file.</p>
<h3 id="timekeeping-next"><a class="header" href="#timekeeping-next"><code>timekeeping-next</code></a></h3>
<p><a href="https://github.com/Rust-for-Linux/linux/tree/timekeeping-next"><code>timekeeping-next</code></a> is the branch for the <a href="https://docs.kernel.org/process/maintainers.html#delay-sleep-timekeeping-timers-rust">&quot;DELAY, SLEEP, TIMEKEEPING, TIMERS [RUST]&quot; entry</a> in the <code>MAINTAINERS</code> file.</p>
<h3 id="xarray-next"><a class="header" href="#xarray-next"><code>xarray-next</code></a></h3>
<p><a href="https://github.com/Rust-for-Linux/linux/tree/xarray-next"><code>xarray-next</code></a> is the branch for the <a href="https://docs.kernel.org/process/maintainers.html#xarray-api-rust">&quot;XARRAY API [RUST]&quot; entry</a> in the <code>MAINTAINERS</code> file.</p>
<h2 id="past-branches"><a class="header" href="#past-branches">Past branches</a></h2>
<p>There are also other branches that are unmaintained, archived, deprecated, frozen or do not exist anymore in the repository. For historical details about these, please see our <a href="Past-branches.html">Past branches</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="past-branches-1"><a class="header" href="#past-branches-1">Past branches</a></h1>
<p>These branches are unmaintained, archived, deprecated, frozen or do not exist anymore in the repository. Historical details about them follow.</p>
<h2 id="rust"><a class="header" href="#rust"><code>rust</code></a></h2>
<p><a href="https://github.com/Rust-for-Linux/linux/tree/rust"><code>rust</code></a> was the original branch where development happened for two years before Rust support was merged into the kernel.</p>
<p>It contains most of the abstractions that the project worked on as a prototype/showcase. Some of those may eventually land upstream, others may be reworked with feedback from upstream, and a few may be dropped if unneeded.</p>
<p>The branch is now archived, thus no new changes are merged into it. While it may be deleted eventually, for the moment it is kept around since some of the code did not make it upstream and may be useful for others.</p>
<p>Similarly, its <a href="https://rust-for-linux.github.io/docs/rust/kernel/">Rust code documentation (2023-03-13)</a> is archived as well.</p>
<p>Changes to this branch landed via <a href="https://github.com/Rust-for-Linux/linux/pulls">GitHub PRs</a>. GitHub Actions was used as a pre-merge CI, compiling the kernel and booting it under QEMU for different toolchains, architectures and configurations. It also checked that some tests passed (e.g. loading sample modules, KUnit tests...) as well as building the PR under Clippy, building the docs, checking <code>rustfmt</code>, etc. <a href="https://linux.kernelci.org/job/rust-for-linux/branch/rust/">KernelCI</a> tests it. Finally, in the past, the <a href="Ksquirrel.html">Ksquirrel</a> bot checked the PRs sent to it.</p>
<h2 id="rust-dev"><a class="header" href="#rust-dev"><code>rust-dev</code></a></h2>
<p><a href="https://github.com/Rust-for-Linux/linux/tree/rust-dev"><code>rust-dev</code></a> was an experimental branch for integration purposes. It was a queue for patches that &quot;looked good enough&quot;.</p>
<p>Its intended use cases were:</p>
<ul>
<li>Finding merge/apply conflicts as early as possible.</li>
<li>Providing a common base for development that requires features that are not yet in mainline or <code>rust-next</code>, i.e. giving early access to features. This may include Rust-related changes from other subsystems, but it was not intended to cover our topic branches.</li>
<li>Providing extra testing to patches by making them easily available to more developers.</li>
</ul>
<p>This branch was intended to be updated/rebased frequently.</p>
<h2 id="topic-branches-staging"><a class="header" href="#topic-branches-staging">Topic branches (<code>staging/*</code>)</a></h2>
<p>These branches were focused on a particular topic and were meant to enable collaboration on code that is targeted for upstreaming but has not reached mainline yet. The intention was to make it easy to request/add new ones.</p>
<p>Some of these branches may contain work-in-progress code (similar to <a href="https://docs.kernel.org/process/2.Process.html?highlight=staging#staging-trees">staging trees</a>) that may not be suitable for upstreaming or general usage yet. Please check the details of each branch.</p>
<p>Changes to these branches landed via GitHub PRs. Nevertheless, contributions should still follow the usual Linux kernel development process — see <a href="Contributing.html">Contributing</a> for details.</p>
<h3 id="stagingdev"><a class="header" href="#stagingdev"><code>staging/dev</code></a></h3>
<p><code>staging/dev</code> was a branch intended to integrate the other topic branches (similar to the role of <code>rust-dev</code> for the main branches).</p>
<h3 id="stagingrust-device"><a class="header" href="#stagingrust-device"><code>staging/rust-device</code></a></h3>
<p><code>staging/rust-device</code> was dedicated to device/driver-related abstractions.</p>
<p>The branch was kept in a compilable state (rebased regularly on top of <code>rust-next</code> or mainline). Fixes and features were welcome.</p>
<h3 id="stagingrust-net"><a class="header" href="#stagingrust-net"><code>staging/rust-net</code></a></h3>
<p><a href="https://github.com/Rust-for-Linux/linux/tree/staging/rust-net"><code>staging/rust-net</code></a> was dedicated to networking-related abstractions.</p>
<p>The branch was kept in a compilable state (rebased regularly on top of <code>rust-next</code> or mainline). Fixes and features were welcome.</p>
<p>It was maintained by Trevor Gross and Valentin Obst. You could contact them through <a href="Contact.html#zulip-chat">Zulip</a>.</p>
<h3 id="stagingrust-pci"><a class="header" href="#stagingrust-pci"><code>staging/rust-pci</code></a></h3>
<p><code>staging/rust-pci</code> was dedicated to PCI-related abstractions, which were used by e.g. the <a href="NVMe-driver.html">NVMe driver</a>.</p>
<p>The branch was kept in a compilable state (rebased regularly on top of <code>rust-next</code> or mainline). Fixes and features were welcome.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-reference-drivers"><a class="header" href="#rust-reference-drivers">Rust reference drivers</a></h1>
<p>Some kernel subsystems maintainers are open to the idea of experimenting with Rust, but they may want to start simple with a driver they are familiar with. But such a driver would violate the &quot;no duplicate drivers&quot; rule.</p>
<p>Similarly, external people have expressed an interest in writing Rust drivers, but given the required abstractions are not there, they may decide to wait. But if nobody writes a first use case, the abstractions cannot be merged without breaking the &quot;no code without an
expected in-tree user&quot; rule.</p>
<p><a href="https://lore.kernel.org/all/CANiq72=99VFE=Ve5MNM9ZuSe9M-JSH1evk6pABNSEnNjK7aXYA@mail.gmail.com/">Rust reference drivers</a> are a solution to these deadlocks: they are drivers that subsystem maintainers are allowed to introduce in their subsystem without dropping the existing C driver. This allows maintainers:</p>
<ol>
<li>
<p>To bootstrap abstractions for new drivers, i.e. not the &quot;duplicate&quot;/&quot;rewritten&quot; one, but future new drivers that would use those abstractions; while avoiding breaking the &quot;no dead code&quot; rule.</p>
</li>
<li>
<p>To serve as a reference for existing C maintainers on how such drivers would look like in Rust, as &quot;live&quot; documentation, e.g. like how <a href="https://lwn.net/Articles/863459/">LWN featured a 1:1 comparison</a> between a C and Rust driver. And it has to be buildable at all times.</p>
</li>
<li>
<p>To use all the in-tree kernel infrastructure and to prepare their subsystem for Rust over time, e.g. setting up tests and CI.</p>
</li>
<li>
<p>To learn over time, especially for subsystems that have several maintainers where not everybody may have time for it at a given moment. Reading Rust patches from time to time for APIs one is familiar with can help a lot.</p>
</li>
<li>
<p>And, most importantly, to evaluate if the effort is worth it for their subsystem. For instance, maintainers may ask themselves:</p>
<ul>
<li>
<p>&quot;How much can we write in safe code?&quot;</p>
</li>
<li>
<p>&quot;How many issues has the reference driver had over time vs. the C one? Did Rust help prevent some?&quot;</p>
</li>
<li>
<p>&quot;How hard is it to maintain the Rust side? Do we have enough resources in our subsystem?&quot;</p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</li>
</ol>
<p>A Rust reference driver does not necessarily need to be considered a real driver, e.g. it could be behind <code>EXPERT</code>, be tagged <code>(EXPERIMENTAL)</code>, staging...</p>
<p>The first driver that took advantage of this framework was <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/net/phy/ax88796b_rust.rs?h=v6.8-rc1"><code>drivers/net/phy/ax88796b_rust.rs</code></a>, merged in v6.8:</p>
<pre><code class="language-kconfig">config AX88796B_RUST_PHY
	bool &quot;Rust reference driver for Asix PHYs&quot;
	depends on RUST_PHYLIB_ABSTRACTIONS &amp;&amp; AX88796B_PHY
	help
	  Uses the Rust reference driver for Asix PHYs (ax88796b_rust.ko).
	  The features are equivalent. It supports the Asix Electronics PHY
	  found in the X-Surf 100 AX88796B package.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-version-policy"><a class="header" href="#rust-version-policy">Rust version policy</a></h1>
<h2 id="supported-versions"><a class="header" href="#supported-versions">Supported versions</a></h2>
<p>The kernel documents the <a href="https://docs.kernel.org/process/changes.html">minimal requirements</a> to compile it. Since v6.11, the kernel supports a minimum version of Rust, starting with Rust 1.78.0.</p>
<p>For the moment, we cannot guarantee newer Rust versions will always work due to the <a href="Unstable-features.html">unstable features</a> in use<sup class="footnote-reference"><a href="#rust-is-stable">1</a></sup>. Removing the need for them is a priority of the project.</p>
<p>To ameliorate that, the kernel is now being <a href="https://rustc-dev-guide.rust-lang.org/tests/rust-for-linux.html">build-tested</a> in Rust's pre-merge CI. That is, every change that is attempting to land into the Rust compiler is tested against the kernel, and it is merged only if it passes. Similarly, the <code>bindgen</code> tool is also <a href="https://github.com/rust-lang/rust-bindgen/pull/2851">build-testing</a> the kernel in their pre-merge CI.</p>
<p>Thus, with the pre-merge CIs in place, those projects hope to avoid unintentional changes to Rust and <code>bindgen</code> that break the kernel. This means that, in general, apart from intentional changes on their side (that we will need to workaround conditionally on our side), the upcoming Rust and <code>bindgen</code> versions should generally work. This applies to beta and nightly versions of Rust as well.</p>
<p>In addition, getting Linux to build on stable Rust has been a &quot;flagship goal&quot; of the Rust project for <a href="https://rust-lang.github.io/rust-project-goals/2024h2/rfl_stable.html">2024H2</a> and <a href="https://rust-lang.github.io/rust-project-goals/2025h1/rfl.html">2025H1</a>. We also have two ongoing goals for 2025H2: <a href="https://rust-lang.github.io/rust-project-goals/2025h2/Rust-for-Linux-language.html">language</a> and <a href="https://rust-lang.github.io/rust-project-goals/2025h2/Rust-for-Linux-compiler.html">compiler</a>.</p>
<div class="footnote-definition" id="rust-is-stable"><sup class="footnote-definition-label">1</sup>
<p>To clarify, the Rust language is stable, i.e. it promises backwards compatibility, except for those unstable features.</p>
</div>
<h2 id="supported-toolchains"><a class="header" href="#supported-toolchains">Supported toolchains</a></h2>
<p>The Rust versions currently supported should already be enough for kernel developers in distributions that provide recent Rust compilers routinely, such as:</p>
<ul>
<li>Arch Linux.</li>
<li>Debian 13 (Trixie), Debian Testing and Debian Unstable (Sid).</li>
<li>Fedora Linux.</li>
<li>Gentoo Linux.</li>
<li>Nix (unstable).</li>
<li>openSUSE Slowroll and Tumbleweed.</li>
<li>Ubuntu LTS (20.04, 22.04, 24.04) and non-LTS (interim).</li>
</ul>
<p>In addition, we support the toolchains distributed by Rust, installed via <a href="https://rust-lang.github.io/rustup/"><code>rustup</code></a> or the <a href="https://forge.rust-lang.org/infra/other-installation-methods.html#standalone-installers">standalone installers</a>.</p>
<p>Finally, slim and fast LLVM+Rust toolchains are provided at <a href="https://kernel.org/pub/tools/llvm/rust/">kernel.org</a>.</p>
<p>Please see the <a href="https://docs.kernel.org/rust/quick-start.html">Quick Start guide</a> for details.</p>
<h2 id="minimum-upgrade-policy"><a class="header" href="#minimum-upgrade-policy">Minimum upgrade policy</a></h2>
<p>We have not upgraded the initial minimum yet (Rust 1.78.0, released 2024-05-02).</p>
<p>Our current plan is to propose Debian Stable's Rust versions as the minimum supported versions to use.</p>
<p>For instance, Debian 13 (Trixie)'s Rust version is 1.85.0 (released 2025-02-20), thus we are aiming to have that one as the new minimum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unstable-features"><a class="header" href="#unstable-features">Unstable features</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The Rust language is stable, i.e. it promises <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">backwards compatibility</a> within the same <a href="https://doc.rust-lang.org/edition-guide/editions/">edition</a>, with a few exceptions, such as reserving the right to patch safety holes. The kernel currently uses Edition 2021.</p>
<p>On top of that, the kernel uses some Rust unstable features. These features can only be accessed by opting into them. They are typically used as a way to introduce new features into the language, library and toolchain to allow end users to experiment with them and provide feedback before committing to them.</p>
<p>&quot;Unstable&quot; in this context means the feature may change in future versions, i.e. backwards compatibility is not promised for those features. It does not imply that the features are broken. For instance, unstable features may be production-ready and ready for stabilization or they may be experimental, incomplete or internal to the compiler.</p>
<p>When unstable features are deemed mature enough, they may get promoted into stable Rust. In other cases, they may get dropped altogether. Some features are internal to the compiler or perma-unstable.</p>
<h2 id="usage-in-the-kernel"><a class="header" href="#usage-in-the-kernel">Usage in the kernel</a></h2>
<p>The unstable features used (or needed, or expected to be needed) in the kernel are tracked at <a href="https://github.com/Rust-for-Linux/linux/issues/2">issue #2</a>.</p>
<p>Most of the features are only allowed within the <code>kernel</code> crate, i.e. for abstractions. Elsewhere (e.g. drivers), only a minimal set is allowed (see the <code>rust_allowed_features</code> variable in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/scripts/Makefile.build"><code>scripts/Makefile.build</code></a>).</p>
<p>Removing the need for unstable features is a priority in order to ensure the kernel can be built with future Rust compiler versions without major changes on the kernel side. To that end, we are working with upstream Rust to get the Linux kernel into stable Rust. On top of that, the kernel is build-tested in the pre-merge CI of the Rust and <code>bindgen</code> projects. Please see the <a href="Rust-version-policy.html">Rust version policy</a> page for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backporting-and-stablelts-releases"><a class="header" href="#backporting-and-stablelts-releases">Backporting and stable/LTS releases</a></h1>
<p>The <a href="https://www.kernel.org/category/releases.html"><em>stable</em> and <em>longterm</em> (LTS) kernel releases</a> only receive fixes, and thus <a href="https://docs.kernel.org/process/stable-kernel-rules.html">do not accept new features</a>. Therefore, it is generally not possible to backport new Rust features or abstractions from mainline. However, exceptions may apply.</p>
<p>We do our best to maintain the existing Rust support in Linux v6.1 LTS, v6.6 LTS and v6.12 LTS:</p>
<ul>
<li>
<p>Linux v6.1 LTS and v6.6 LTS have the Rust compiler version pinned, i.e. a single version of Rust works with each of those releases.</p>
</li>
<li>
<p>Linux v6.12 LTS is the first LTS that had a minimum supported Rust version, i.e. unpinned.</p>
<p>We will do our best to avoid having to establish a maximum Rust version for that LTS, i.e. to support future Rust releases. However, given the use of unstable features back then, we cannot guarantee it.</p>
</li>
</ul>
<h2 id="older-lts-releases"><a class="header" href="#older-lts-releases">Older LTS releases</a></h2>
<p>There has been some interest over time in backported Rust support for Linux v5.10 LTS and v5.15 LTS.</p>
<p>In general, maintaining an LTS branch, even if based on an official one, requires substantial effort and a long-term commitment, as it should be consistently supported until reaching its End of Life. If we were to consider it, there would need to be a strong demand and/or additional resources provided. If your company, organization or team would be interested, then please <a href="Contact.html">contact us</a>.</p>
<p>There would be several points to consider:</p>
<ul>
<li>
<p>The level of support and the security and scheduling implications.</p>
</li>
<li>
<p>Whether all new abstractions, drivers and overall features appearing in mainline are backported, and whether those that require extra backports on the C side to support them should be included.</p>
</li>
<li>
<p>Whether the Rust version policy would be different than the one in mainline, e.g. whether the Rust version would be fixed (like it is in older upstream LTS kernels).</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="third-party-crates"><a class="header" href="#third-party-crates">Third-party crates</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Rust provides a package manager and build system called <a href="https://doc.rust-lang.org/cargo/">Cargo</a>. Rust also provides <a href="https://crates.io">crates.io</a>, its default package registry. In userspace, all these form a solution that a lot of open-source Rust projects use.</p>
<p>Some of those open-source libraries are potentially usable in the kernel because they only depend on <code>core</code> (and possibly <code>alloc</code>) rather than <code>std</code>, or because they only provide macro facilities.</p>
<p>Thus it is natural to consider whether some of these libraries could be reused for the kernel.</p>
<h2 id="suitability-of-a-crate"><a class="header" href="#suitability-of-a-crate">Suitability of a crate</a></h2>
<p>Even if a library only depends on <code>core</code> (and possibly <code>alloc</code>), it may still not be usable within the kernel for other reasons.</p>
<p>For instance, its license may be incompatible, its use of the Rust standard library <code>alloc</code> crate (if any) may not be easy to adapt to the kernel's <code>alloc</code> module, the kernel may only need a very small subset of what it supports (even if it supports configuring out some of its features), the kernel may already provide the same functionality on the C side (which could be abstracted), etc.</p>
<p>On top of that, the code of a crate may require some changes to be adapted for the kernel anyway. For instance, adding SPDX license identifiers, removing a dependency, tweaking some code, enabling an unstable feature, etc.</p>
<p>Moreover, new code arriving to the kernel should be maintained; and thus somebody needs to step up for that role.</p>
<p>Therefore, in general, whether a third-party crate is suitable for the kernel needs to be decided on a case-by-case basis.</p>
<h2 id="importing-crates"><a class="header" href="#importing-crates">Importing crates</a></h2>
<p>The kernel currently integrates some dependencies by importing the files into its source tree, adapted as needed. In other words, they are not fetched/patched on demand. For instance, in the C side, some of the compression algorithms; in the Rust side, <code>proc-macro2</code>, <code>quote</code> and <code>syn</code> since v6.19; and in older kernel releases, our Rust <code>alloc</code> fork.</p>
<p>There have been discussions about potentially incorporating a system where crates/libraries are fetched dynamically given a list of crates, versions, hashes, etc.; however, it remains to be seen whether such a system would be preferred and accepted.</p>
<h2 id="supporting-out-of-tree-modules"><a class="header" href="#supporting-out-of-tree-modules">Supporting out-of-tree modules</a></h2>
<p>The project is focused on getting features upstreamed, i.e. available for everybody. Therefore, if mainline does not support third-party crates and/or a system to fetch them dynamically, then it is unlikely it will be supported for out-of-tree modules.</p>
<h2 id="experiment"><a class="header" href="#experiment">Experiment</a></h2>
<p>Experimental integration for a few popular crates has been provided for interested users, e.g. <a href="https://github.com/Rust-for-Linux/linux/pull/1007">PR #1007</a> added support for <code>proc-macro2</code>, <code>quote</code>, <code>syn</code>, <code>serde</code> and <code>serde_derive</code> (<code>syn</code> and its dependencies have been integrated in mainline since v6.19).</p>
<h2 id="feedback"><a class="header" href="#feedback">Feedback</a></h2>
<p>We are looking for <a href="Contact.html">feedback</a> from other kernel developers, maintainers and companies on which third-party crates would be most useful to have in the kernel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="out-of-tree-modules"><a class="header" href="#out-of-tree-modules">Out-of-tree modules</a></h1>
<p>The Linux kernel supports <a href="https://docs.kernel.org/kbuild/modules.html">building out-of-tree modules</a>. Both C and Rust modules can be developed as out-of-tree ones, and we provide a <a href="https://github.com/Rust-for-Linux/rust-out-of-tree-module">basic template</a> for an out-of-tree Linux kernel module written in Rust.</p>
<p>However, please note that the Rust for Linux project is part of the kernel and has always focused its efforts towards getting code into the mainline kernel.</p>
<p>In particular, this means that Rust <a href="https://docs.kernel.org/process/4.Coding.html#internal-api-changes">internal APIs can be changed at any time</a>, just like C ones, when the need arises. Similarly, code present at any point in our different <a href="Branches.html">branches</a> is not intended to form a stable base for out-of-tree development.</p>
<p>In addition, patches submitted to the mailing list should generally focus on in-tree development efforts. In particular, Rust abstractions submitted upstream require in-tree users. Abstractions intended for out-of-tree users cannot be merged. Even if those abstractions may be obviously useful for future in-tree users, there needs to be an agreed upon in-tree user.</p>
<p>For these reasons and others, please consider <a href="Contributing.html">submitting</a> your use cases upstream — see <a href="https://docs.kernel.org/process/1.Intro.html#the-importance-of-getting-code-into-the-mainline">the importance of getting code into the mainline</a>.</p>
<p>Having said that, we understand that some module development is done out-of-tree and may not be possible to upstream. Even in those cases, if your company, organization or team has a use case for Rust, please <a href="Contact.html">contact us</a>, since it is important to highlight those use cases early on in order to showcase the <a href="Industry-and-academia-support.html">interest from industry and academia</a> in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="industry-and-academia-support"><a class="header" href="#industry-and-academia-support">Industry and academia support</a></h1>
<blockquote id="Google" class="quote-highlight">
<p>“Google supports and contributes directly to the Rust for Linux project. Our Android team is evaluating a new Binder implementation and considering other drivers where Rust could be adopted.”</p>
</blockquote>
<p>— <a href="https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/">Google</a>, 2021.</p>
<blockquote id="Arm" class="quote-highlight">
<p>“Arm recognises the Rust value proposition and is actively working with the Rust community to improve Rust for Arm based systems.
A good example is Arm’s RFC contribution to the Rust language which made Linux on 64-bit Arm systems a Tier-1 Rust supported platform.</p>
<p>Rustaceans at Arm are excited about the Rust for Linux initiative and look forward to assisting in this effort.”</p>
</blockquote>
<p>— <a href="https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/">Arm</a>, 2021-06-29.</p>
<blockquote id="Microsoft" class="quote-highlight">
<p>“Microsoft's Linux Systems Group is interested in contributing to getting Rust into Linux kernel. Hopefully we will be able to submit select Hyper-V drivers written in Rust in the coming months.”</p>
</blockquote>
<p>— <a href="https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/">Microsoft</a>, 2021-06-29.</p>
<blockquote id="RedHat" class="quote-highlight">
<p>“There is interest in using Rust for kernel work that Red Hat is considering.”</p>
</blockquote>
<p>— <a href="https://lore.kernel.org/lkml/20211206140313.5653-1-ojeda@kernel.org/">Red Hat</a>, 2021-07-08.</p>
<blockquote id="Anderson" class="quote-highlight">
<p>“Rust for Linux is a key step towards reducing security-critical kernel bugs, and on the path towards our ultimate goal of making Linux free of security-critical bugs. We are using Rust in our OS research, and adoption is easier with an existing Rust in the Linux kernel framework in place.”</p>
</blockquote>
<p>— Thomas Anderson, University of Washington, 2022-06-23.</p>
<blockquote id="BlancCohenSchmidt" class="quote-highlight">
<p>“We are convinced that Rust is changing the landscape of system programming by applying the research done on programming languages in the last decades. We wanted to see how the language was able to help us write code we are really comfortable with thanks to the extensive static checking.”</p>
</blockquote>
<p>— Esteban Blanc, Arthur Cohen and Martin Schmidt, LSE (Systems Research Laboratory) at EPITA (École pour l'informatique et les techniques avancées), 2022-06-23.</p>
<blockquote id="ISRG" class="quote-highlight">
<p>“Being able to use Rust in the Linux kernel is an incredible milestone on the road to a more secure future for the Internet and everything else that depends heavily on Linux.”</p>
</blockquote>
<p>— <a href="https://www.memorysafety.org/blog/rust-in-linux-just-the-beginning/">ISRG's Prossimo Project</a>, 2022-10-18.</p>
<blockquote id="Samsung" class="quote-highlight">
<p>“Samsung is actively engaged in supporting the integration of Rust code into the Linux Kernel. Recognizing the significant benefits that Rust brings to kernel and system software development, particularly in terms of enhancing security and reducing critical bugs, Samsung is committed to enabling kernel developers to write block layer device drivers using the Rust programming language. By embracing modern programming languages like Rust, Samsung aims to attract new talent to systems development and promote memory safety within the Linux storage stack.”</p>
</blockquote>
<p>— Samsung, 2023-05-17.</p>
<blockquote id="Cisco" class="quote-highlight">
<p>“Cisco supports the inclusion and development of Rust in the Linux kernel as a way of eliminating memory safety bugs and vulnerabilities. We are developing a next-generation container filesystem in Rust and, to this end, we are contributing time, code, and the testing effort to the Rust for Linux project.”</p>
</blockquote>
<p>— Cisco, 2023-09-14.</p>
<blockquote id="Collabora" class="quote-highlight">
<p>“Collabora feels privileged to partner with customers who envision Rust as an integral part of the Linux kernel's future. We are committed to supporting the integration of Rust into as many Linux subsystems as appropriate over the coming years. By doing so, this will enable our customers, and many more developers, to increase the reliability of their Linux kernel contributions. We extend our gratitude for the activities undertaken by the Rust for Linux Initiative.”</p>
</blockquote>
<p>— Collabora, 2023-09-22.</p>
<blockquote id="CDN77" class="quote-highlight">
<p>“CDN77 builds most new projects in Rust. This leads to more secure code, fewer critical bugs, and a codebase that scales without breaking existing logic. We’re also testing Rust in the Linux kernel with promising results, and we fully support its inclusion.”</p>
</blockquote>
<p>— CDN77, 2025-09-24.</p>
<hr />
<p>If your company, organization, university or team is using or plans to use Rust for Linux and would like to release a statement, then please <a href="Contact.html">contact us</a>. Thank you!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sponsors"><a class="header" href="#sponsors">Sponsors</a></h1>
<h2 id="prossimo-project"><a class="header" href="#prossimo-project">Prossimo project</a></h2>
<p><a href="https://www.abetterinternet.org">Internet Security Research Group (ISRG)</a>, through their <a href="https://www.memorysafety.org/initiative/linux-kernel/">Prossimo</a> project, supported Miguel Ojeda and Gary Guo to work on Rust for Linux, which was made possible with financial support from Google, Futurewei and Alpha-Omega.</p>
<blockquote style="display: flex; column-gap: 20px; align-items: center;flex-wrap: wrap;">
  <div style="flex: 0 1 300px; margin-top: 20px; margin-bottom: 20px;background: white;padding: 30px;border-radius: 10px;row-gap: 20px;display: flex;flex-direction: column;margin-left: auto;margin-right: auto;">
    <a href="https://www.abetterinternet.org"><img src="ISRG.svg" alt="ISRG Logo"></a>
    <a href="https://www.memorysafety.org"><img src="Prossimo.svg" alt="Prossimo Logo"></a>
  </div>
  <div style="flex: 300px;">
    <p>“Our mission is to reduce financial, technological, and educational barriers to secure communication over the Internet.”</p>
    <p>“Prossimo is an Internet Security Research Group (ISRG) project. Its goal is to improve the Internet's security-sensitive software infrastructure by addressing memory safety issues in C and C++ code via the use of memory safe languages.”</p>
  </div>
</blockquote>
<div style="background: white; margin-top: 2.5em; border-radius: 10px; padding: 20px; display: flex; align-items: center; justify-content: center; column-gap: 4%;">
    <div style="flex: 1 1 0;"><img style="width: 100%; height: auto;" src="Google.svg" alt="Google Logo"></div>
    <div style="flex: 1 1 0;"><img style="width: 100%; height: auto;" src="Futurewei.png" alt="Futurewei Logo"></div>
    <div style="flex: 1 1 0;"><img style="width: 100%; height: auto;" src="Alpha-Omega.svg" alt="Alpha-Omega Logo"></div>
</div>
<h2 id="zulip"><a class="header" href="#zulip">Zulip</a></h2>
<p><a href="https://zulip.com">Zulip</a> sponsors free Zulip Cloud Standard hosting for Rust for Linux.</p>
<blockquote style="display: flex; column-gap: 20px; align-items: center;">
  <div style=" flex: 0 0 50px; margin-top: 20px; margin-bottom: 20px;">
    <a href="https://zulip.com"><img src="Zulip.svg" alt="Zulip Logo"></a>
  </div>
  <p>“Zulip is an open-source modern team chat app designed to keep both live and asynchronous conversations organized.”</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="klint"><a class="header" href="#klint"><code>klint</code></a></h1>
<p><a href="https://github.com/Rust-for-Linux/klint"><code>klint</code></a> is a tool that allows to introduce extra static analysis passes (&quot;lints&quot;) in Rust kernel code, leveraging the Rust compiler as a library. One of the first lints available <a href="https://www.memorysafety.org/blog/gary-guo-klint-rust-tools/">validates that Rust code follows the kernel locking rules</a> by tracking the preemption count at compile-time.</p>
<p>The main developer and maintainer is Gary Guo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pin-init"><a class="header" href="#pin-init"><code>pin-init</code></a></h1>
<p><a href="https://github.com/Rust-for-Linux/pin-init"><code>pin-init</code></a> is a solution to <a href="The-Safe-Pinned-Initialization-Problem.html">The Safe Pinned Initialization Problem</a>. It provides safe and fallible initialization of pinned structs using in-place constructors.</p>
<p>The main developer and maintainer is <a href="https://github.com/BennoLossin/">Benno Lossin</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-safe-pinned-initialization-problem"><a class="header" href="#the-safe-pinned-initialization-problem">The Safe Pinned Initialization Problem</a></h1>
<h2 id="introduction-to-pinning"><a class="header" href="#introduction-to-pinning">Introduction to Pinning</a></h2>
<p>In the kernel many data structures are not allowed to change address, since there exist external pointers to them that would then be invalidated. Since this could cause memory errors, Rust has to <em>somehow</em> guarantee that this cannot happen in safe code. Luckily there already exists the <a href="https://doc.rust-lang.org/core/pin/struct.Pin.html"><code>Pin&lt;P&gt;</code></a> wrapper type for arbitrary pointer types <code>P</code>. For simplicity we will look at <code>P = Box&lt;T&gt;</code>. <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> is a smart pointer that owns a <code>T</code> (a generic parameter) allocated on the heap. When a <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> is dropped (destroyed) then it automatically frees the memory.</p>
<p><code>Pin&lt;Box&lt;T&gt;&gt;</code> behaves similar to <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>, it is also a smart pointer and allows you to have immutable access to the fields and functions of <code>T</code>. You can also store it just as easily, since it also has the same size as <code>Box&lt;T&gt;</code>.</p>
<p>One important difference compared to just <code>Box&lt;T&gt;</code> is that <code>Pin</code> prevents mutable access to the underlying <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> and thus makes it impossible to move the pointee. So users are unable to call e.g. <a href="https://doc.rust-lang.org/core/mem/fn.swap.html"><code>mem::swap</code></a>. This is of course a heavy restriction, so there exist <code>unsafe</code> functions that allow modification and access to <code>&amp;mut T</code> and so called pin-projections to access fields of <code>T</code>. However, when using these functions, it is the caller's responsibility to uphold the pinning guarantee.</p>
<p>This guarantee also includes that the object is <code>drop</code>ed before the memory is deallocated or repurposed. At first glance, this requirement seems strange. But after this example it will hopefully seem very natural. Let's imagine that we want to design a Rust version of <code>list_head</code><sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Invariants
///
/// `next` and `prev` always point to a valid `ListHead`.
struct ListHead {
    next: *mut ListHead,
    prev: *mut ListHead,
}
<span class="boring">}</span></code></pre></pre>
<p>Then we need to ensure that as long as an element is in a list, it will stay alive, since it would cause a UAF (use after free) otherwise. A simple way to achieve this, is to remove it from the list, when it gets dropped:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for ListHead {
    fn drop(&amp;mut self) {
        let prev = self.prev;
        let next = self.next;
        // SAFETY: By the invariant, these pointers are valid.
        unsafe {
            (*next).prev = prev;
            (*prev).next = next;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And this is the important bit, if we were to just deallocate/reuse the memory of a <code>ListHead</code> without dropping it first, by e.g. using <a href="https://doc.rust-lang.org/core/ptr/fn.write.html"><code>ptr::write</code></a>, then we are just begging for a UAF to happen.</p>
<p>Because the <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> smart pointer owns its memory, it cannot be used for a function which does not consume the value. For this reason the mutable reference <code>&amp;mut T</code> is used. When dealing with <code>Pin&lt;Box&lt;T&gt;&gt;</code>, we cannot access <code>&amp;mut T</code>. Instead we can access <code>Pin&lt;&amp;mut T&gt;</code> which still upholds the pinning guarantee.</p>
<h2 id="adding-initialization-into-the-mix"><a class="header" href="#adding-initialization-into-the-mix">Adding Initialization into the mix</a></h2>
<p>What does initialization have to do with pinning? In the first paragraph nothing suggested that there would be a connection. One important feature of Rust forces this connection. In Rust all values have to be initialized at <em>all</em> times. This is a problem for creating our <code>ListHead</code> the usual Rust way; a <code>new()</code> function that returns the object by value. Since we first need to know its address before we can initialize <code>next</code> and <code>prev</code> to point to itself.</p>
<p>Rust has a way around the &quot;values are vaild at all times&quot; problem: <code>MaybeUninit&lt;T&gt;</code> is a wrapper that explicitly allows uninitialized values. <code>unsafe</code> functions are then used to access the <code>T</code> once initialized. For our <code>ListHead</code> we could simply allocate a <code>MaybeUninit&lt;ListHead&gt;</code> and then write its address using raw pointers into <code>next</code> and <code>prev</code>. However, as already said above, in Rust the normal way of creating an object is to return it by value. We cannot do this for the <code>ListHead</code>, since that would move it and invalidate its pointers. The alternative of allocating it on the heap, i.e. returning a <code>Pin&lt;Box&lt;ListHead&gt;&gt;</code> also does not work, since this list should be part of a bigger struct.</p>
<p>This is the reason why Rust-for-Linux chose a two-function approach:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ListHead {
    /// Creates a new [`ListHead`].
    ///
    /// # Safety
    ///
    /// Before using this [`ListHead`] the caller has to call [`ListHead::init`].
    unsafe fn new() -&gt; Self {
        Self {
            next: ptr::null_mut(),
            prev: ptr::null_mut(),
        }
    }

    /// Initializes this [`ListHead`].
    ///
    /// # Safety
    ///
    /// This function is only called once.
    unsafe fn init(self: Pin&lt;&amp;mut Self&gt;) {
        // SAFETY: We do not move `self`.
        let this: &amp;mut Self = unsafe { self.get_unchecked_mut() };
        let ptr: *mut ListHead = this;
        unsafe {
            (*ptr).prev = ptr;
            (*ptr).next = ptr;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach avoids having to allocate and lets the user decide the memory location of the <code>ListHead</code>. It also ensures that a <code>ListHead</code> will be pinned in memory, since the <code>self</code> type of <code>init</code> is <code>Pin&lt;&amp;mut Self&gt;</code>. Both functions have to be marked <code>unsafe</code>, since the safety preconditions cannot be enforced by the compiler. We also have to use two functions, since after a call to <code>new</code> the caller will have to pin the value in memory prior to calling <code>init</code>.</p>
<p>The biggest problem with this approach is that it exclusively relies on the programmer to ensure safety. It is very easy to forget such an <code>init</code> call when you have a struct with multiple fields that require this treatment. This problem is exacerbated by the fact that this API propagates to all structs that contain a <code>ListHead</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DoubleList {
    list_a: ListHead,
    list_b: ListHead,
}

impl DoubleList {
    /// # Safety
    ///
    /// Before using this [`DoubleList`] the caller has to call [`DoubleList::init`].
    unsafe fn new() -&gt; Self {
        Self {
            // SAFETY: We call `ListHead::init` in our own initializer.
            list_a: unsafe { ListHead::new() },
            // SAFETY: We call `ListHead::init` in our own initializer.
            list_b: unsafe { ListHead::new() },
        }
    }

    /// # Safety
    ///
    /// This function is only called once.
    unsafe fn init(self: Pin&lt;&amp;mut Self&gt;) {
        // SAFETY: We structurally pin `list_a`.
        let list_a = unsafe { self.map_unchecked_mut(|s| &amp;mut s.list_a) };
        // SAFETY: Our function is only called once.
        unsafe { ListHead::init(list_a) };
        // SAFETY: We structurally pin `list_b`.
        let list_b = unsafe { self.map_unchecked_mut(|s| &amp;mut s.list_b) };
        // SAFETY: Our function is only called once.
        unsafe { ListHead::init(list_b) };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>So not only the <code>kernel</code> crate developers have to cope with this API, but <em>everyone</em> who dares to have a <code>Mutex&lt;T&gt;</code> in their struct, or use a struct that transitively contains a <code>Mutex&lt;T&gt;</code>.</p>
<h2 id="pin-complications"><a class="header" href="#pin-complications">Pin Complications</a></h2>
<p>The previous example also shows a different, but related issue: pin-projections. These are how we access the fields of pinned structs. And because one can break the pinning guarantee the <code>map_unchecked_mut</code> function has to be <code>unsafe</code>. The requirement for them is consistency, you are only allowed to either structurally pin a field, so you allow the access of <code>Pin&lt;&amp;mut Struct&gt; -&gt; Pin&lt;&amp;mut Field&gt;</code>, or you do not structurally pin the field, i.e. allowing <code>Pin&lt;&amp;mut Struct&gt; -&gt; &amp;mut Field</code>. As long as only one of those options is done, the pinning guarantee is upheld.</p>
<p>In userland Rust this problem is addressed by using the <a href="https://crates.io/crates/pin-project"><code>pin-project</code></a> crate. This crate generates the pin-projections from the struct definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pin_project]
struct DoubleList {
    #[pin]
    list_a: ListHead,
    #[pin]
    list_b: ListHead,
}
<span class="boring">}</span></code></pre></pre>
<p>Now both fields are structurally pinned and can be safely accessed.</p>
<p>This crate cannot be used in the kernel, since it relies on <a href="https://crates.io/crates/syn"><code>syn</code></a> -- the de facto Rust code parsing library for proc-macros. The problem with including <a href="https://crates.io/crates/syn"><code>syn</code></a> in the kernel is that it consists of over 50k lines of code.</p>
<p>There is also the <a href="https://crates.io/crates/pin-project-lite"><code>pin-project-lite</code></a> crate that achieves almost the same thing without a proc-macro. It has 5k lines of code and contains a very complex macro that would require further modification to serve this purpose, which would be hard to maintain.</p>
<p>These reasons ultimately resulted in not using any of the existing approaches. The problem of pin projections also prompted the creation of the <a href="https://github.com/rust-lang/rfcs/pull/3318">field projection RFC</a>.</p>
<p>If you now want to view how to use the API, then take a look at the <a href="https://rust-for-linux.github.io/docs/pinned-init/kernel/init/">extensive documentation</a>.</p>
<h2 id="further-resources-on-pinning"><a class="header" href="#further-resources-on-pinning">Further Resources on Pinning</a></h2>
<ul>
<li>Rust documentation: <a href="https://doc.rust-lang.org/core/pin/index.html">https://doc.rust-lang.org/core/pin/index.html</a></li>
<li>Pinning and its problems outlined in the context of futures: <a href="https://fasterthanli.me/articles/pin-and-suffering">https://fasterthanli.me/articles/pin-and-suffering</a></li>
<li>Pinning in Rust -- Kangrejos Presentation <a href="https://kangrejos.com">https://kangrejos.com</a> Slides: <a href="https://kangrejos.com/Pinning%20in%20Rust.pdf">https://kangrejos.com/Pinning%20in%20Rust.pdf</a></li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The example presented here, glosses over some very important details. The <code>next</code> and <code>prev</code>
fields of the <code>ListHead</code> struct should actually be placed in <a href="https://doc.rust-lang.org/core/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a>s to allow modification
through <code>&amp;ListHead</code>, since we cannot have multiple <code>&amp;mut ListHead</code>s at the same time. And we
need to have multiple when iterating through a list. Also, <code>ListHead</code> should contain a
<code>PhantomPinned</code> field to ensure it cannot be unpinned.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arc-in-the-linux-kernel"><a class="header" href="#arc-in-the-linux-kernel"><code>Arc</code> in the Linux kernel</a></h1>
<p>This document outlines how the Linux kernel is using the unstable features <a href="https://github.com/rust-lang/rust/issues/44874"><code>arbitrary_self_types</code></a> and <code>dispatch_from_dyn</code>/<a href="https://github.com/rust-lang/rust/issues/18598"><code>unsize</code></a>.</p>
<p>But first, an introduction to the custom types that the kernel is using.</p>
<h2 id="the-kernels-custom-arc"><a class="header" href="#the-kernels-custom-arc">The kernel's custom <code>Arc</code></a></h2>
<p>The Linux kernel needs to use a <a href="https://rust-for-linux.github.io/docs/v6.8/kernel/sync/struct.Arc.html">custom implementation of <code>Arc</code></a>. The most important reason is that we need to use the kernel's <code>refcount_t</code> type for the atomic instructions on the refcount. There are two reasons for this:</p>
<ol>
<li>
<p>The <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">standard Rust <code>Arc</code></a> will call <code>abort</code> on overflow. This is not acceptable in the kernel; instead we want to saturate the count when it hits <code>isize::MAX</code>. This effectively leaks the <code>Arc</code>.</p>
</li>
<li>
<p>Using Rust atomics raises various issues with the memory model. We are using the LKMM rather than the usual C++ model, which means that all atomic operations should be implemented with an <code>asm!</code> block or similar that matches what kernel C does, rather than an LLVM intrinsic.</p>
</li>
</ol>
<p>We also make a few other changes to our <code>Arc</code>:</p>
<ol>
<li>
<p>We need to interact with a lot of different C types that need to be pinned, so our custom <code>Arc</code> is implicitly pinned.</p>
</li>
<li>
<p>We do not need weak references, so our refcount can be half the size.</p>
</li>
</ol>
<p>Our <code>Arc</code> also comes with two utility types:</p>
<ol>
<li>
<p><a href="https://rust-for-linux.github.io/docs/v6.8/kernel/sync/struct.ArcBorrow.html"><code>ArcBorrow&lt;'a, T&gt;</code></a>. Similar to <code>&amp;'a Arc&lt;T&gt;</code>, but only one level of indirection.</p>
</li>
<li>
<p><a href="https://rust-for-linux.github.io/docs/v6.8/kernel/sync/struct.UniqueArc.html"><code>UniqueArc&lt;T&gt;</code></a>. Mutable access to an <code>Arc</code>. Used to split allocation and initialization into two steps, which is important since we cannot allocate memory while holding a spinlock.</p>
</li>
</ol>
<h2 id="intrusive-linked-lists"><a class="header" href="#intrusive-linked-lists">Intrusive linked lists</a></h2>
<p>The kernel uses a lot of intrusive linked lists, which are extremely rare in userspace Rust. This is a consequence of a unique limitation in kernel code related to memory allocations:</p>
<ol>
<li>
<p>Memory allocations are always fallible and failures must be handled gracefully.</p>
</li>
<li>
<p>When you are in an atomic context (e.g. when holding a spinlock), you are not allowed to allocate memory at all.</p>
</li>
</ol>
<p>(Technically there are special ways to allocate memory in atomic context, but it should be used sparingly.)</p>
<p>These limitations greatly affect how we design code in the kernel. There are some functions where having a failure path is not acceptable (e.g. destroying something), and other places where we cannot allocate at all. This means that we need data structures that do not need to allocate. Or where the allocation and insert steps are separate. Imagine a map protected by a spinlock. How do you implement that if <code>insert</code> simply cannot allocate memory?</p>
<p>One answer to this is to use a linked list (and similar, e.g. a red/black tree can work with the same idea). The value you wish to insert takes this form:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyValue {
    // In practice, these are wrapped into one field using a struct.
    next: *mut MyValue,
    prev: *mut MyValue,
    foo: Foo,
    bar: Bar,
}
<span class="boring">}</span></code></pre></pre>
<p>Then, given an <code>Arc&lt;MyValue&gt;</code>, you can insert that into a linked list without having to allocate memory. The only thing you have to do is adjust the <code>next</code>/<code>prev</code> pointers.</p>
<p>Additionally, there are a bunch of C APIs that work using the same principle, so we are also forced into this pattern when we want to use those C APIs. For example, this includes the workqueue which stores the list of tasks to run in a linked list.</p>
<h3 id="the-listarc-type"><a class="header" href="#the-listarc-type">The <code>ListArc</code> type</a></h3>
<p>You may have noticed one problem with the above design: The value we are inserting is an <code>Arc&lt;MyValue&gt;</code>, so how can you get mutable access to <code>next</code>/<code>prev</code>? And how do you know that it's not already in a linked list? What about data races — someone could attempt to push (two clones of) the same <code>Arc&lt;MyValue&gt;</code> to two different linked lists, which would constitute a data race on the <code>next</code>/<code>prev</code> fields.</p>
<p>You could solve these issues by adding an <code>AtomicBool</code> for keeping track of whether it is in a list, but this isn't great. We really want to avoid the <code>AtomicBool</code>.</p>
<p>Our answer is another custom smart pointer type: <code>ListArc</code>. The <code>ListArc</code> type is just a newtype wrapper around <code>Arc</code> with the invariant that each <code>MyStruct</code> has at most one <code>ListArc</code> reference. However, unlike <code>UniqueArc</code>, you are allowed to have <code>Arc</code> references to a value that also has an <code>ListArc</code>. This way, the <code>ListArc</code> reference can be given exclusive access to the <code>next</code>/<code>prev</code> fields, which is enough to design a safe API for intrusive linked lists containing reference counted values.</p>
<p>One consequence of this is that (unlike <code>Arc</code>), we are using a smart pointer where ownership of the pointer is extremely important. You cannot just <code>clone</code> a <code>ListArc</code>.</p>
<p>Our <code>ListArc</code> type also has a second generic parameter, which allows you to have multiple <code>next</code>/<code>prev</code> pairs. So <code>ListArc&lt;T, 1&gt;</code> has exclusive access to the first <code>next</code>/<code>prev</code> pair, and <code>ListArc&lt;T, 2&gt;</code> has exclusive access to the second such pair. This means that you can have multiple list arcs as long as their parameter is different (one per value of the extra generic parameter).</p>
<h3 id="nextprev-pointers-and-dynamic-dispatch"><a class="header" href="#nextprev-pointers-and-dynamic-dispatch"><code>next</code>/<code>prev</code> pointers and dynamic dispatch</a></h3>
<p>We want to be able to use linked lists with <code>dyn Trait</code>. However, the offset of the <code>next</code>/<code>prev</code> fields needs to be uniform no matter what the concrete type is. To do that, we use a wrapper type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Wrapper&lt;T: ?Sized&gt; {
    next: *mut Wrapper&lt;T&gt;,
    prev: *mut Wrapper&lt;T&gt;,
    value: T,
}
<span class="boring">}</span></code></pre></pre>
<p>And the actual type ends up being <code>Arc&lt;Wrapper&lt;dyn Trait&gt;&gt;</code>.</p>
<h2 id="arbitrary-self-types"><a class="header" href="#arbitrary-self-types">Arbitrary self types</a></h2>
<p>We wish to use arbitrary self types in various places. Some examples:</p>
<ol>
<li>
<p>Many methods need to call <code>self.clone()</code> and get a new <code>Arc</code> to the current struct. To do that, we need <code>self: &amp;Arc&lt;T&gt;</code> or <code>self: ArcBorrow&lt;'_, T&gt;</code>.</p>
</li>
<li>
<p>We often need to do <code>linked_list.push(self)</code>. To do that, we need <code>self: ListArc&lt;T&gt;</code>.</p>
</li>
</ol>
<p>For the struct methods, we <em>could</em> work around this by not using <code>self</code> parameters, and calling <code>MyStruct::foo(my_arc)</code>. However, we also need to do these things in traits where we perform dynamic dispatch on the value. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait WorkItem {
    fn run1(self: ListArc&lt;Self&gt;);

    // or, actually:
    fn run2(self: ListArc&lt;Wrapper&lt;Self&gt;&gt;);
}
<span class="boring">}</span></code></pre></pre>
<p>This use-case needs both arbitrary self types and the dynamic dispatch feature mentioned in the next section. Arbitrary self types are needed because dynamic dispatch is only performed on self parameters.</p>
<h2 id="dynamic-dispatch"><a class="header" href="#dynamic-dispatch">Dynamic dispatch</a></h2>
<p>We wish to use these linked lists to store dynamic trait objects. This is used for a &quot;todo list&quot; of events that need to be delivered to userspace. There are many different event types, and we use a trait object to store a queue of them.</p>
<p>There is a need to have both <code>Arc&lt;MyStruct&gt;</code> and <code>Arc&lt;dyn MyTrait&gt;</code> references to the same object.</p>
<p>All of the smart pointers that we want to use dynamic dispatch with are newtype wrappers around either <code>NonNull</code> or other smart pointers (e.g. <code>ListArc</code> is a wrapper around <code>Arc</code>). They may also have a <code>PhantomData</code> field. These requirements match what is listed on <a href="https://doc.rust-lang.org/stable/std/ops/trait.DispatchFromDyn.html"><code>DispatchFromDyn</code></a>.</p>
<p>A related feature is the <a href="https://doc.rust-lang.org/stable/std/marker/trait.Unsize.html"><code>Unsize</code></a> trait. Most likely, adding the <code>DispatchFromDyn</code> trait depends on also having <code>Unsize</code>, so we need it for that reason. But we do not otherwise need the <code>Unsize</code> trait.</p>
<h3 id="c-to-rust-dynamic-dispatch"><a class="header" href="#c-to-rust-dynamic-dispatch">C-to-Rust dynamic dispatch</a></h3>
<p>The kernel also has some other uses of dynamic dispatch that trait objects don't help with. Mainly, these are cases where C defines a vtable using a struct with function pointers. Here, we must match the vtable layout that C dictates, so we will manually implement the vtable unsafely to handle these cases. We still use a trait for providing a safe API to these things, but the implementation needs only generics and not trait objects.</p>
<p>However, for Rust-to-Rust dynamic dispatch, trait objects appear to satisfy our needs. As long as we are able to use them with our smart pointers, that is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ksquirrel"><a class="header" href="#ksquirrel">Ksquirrel</a></h1>
<p><a href="https://github.com/ksquirrel">Ksquirrel</a> was a GitHub bot that helped newcomers to the kernel get accustomed to the kernel requirements for submissions (e.g. checking that commit messages were properly signed and formatted). It was also useful as a double-check for maintainers that they did not forget to check those requirements.</p>
<p>We may bring it back for mailing list submissions!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coccinelle-for-rust"><a class="header" href="#coccinelle-for-rust">Coccinelle for Rust</a></h1>
<p>Coccinelle is a tool for automatic program matching and transformation that
was originally developed for making large scale changes to the Linux kernel
source code (ie, C code).  Matches and transformations are driven by
user-specific transformation rules having the form of abstracted patches,
referred to as semantic patches. As the Linux kernel, and systems software
more generally, is starting to adopt Rust, we are developing Coccinelle for
Rust, to make the power of Coccinelle available to Rust codebases.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Changing a method call sequence in the Rust implementation:</p>
<pre><code class="language-diff hljs"><span class="hljs-title">@@</span>
<span class="hljs-keyword">expression</span> tcx, arg;
<span class="hljs-title">@@</span>
<span class="hljs-deletion">- tcx.type_of(arg)</span>
<span class="hljs-addition">+ tcx.bound_type_of(arg).subst_identity()</span>
</code></pre>
<p>Replace Generic Bound with Impl Trait:</p>
<pre><code class="language-diff hljs"><span class="hljs-title">@@</span>
<span class="hljs-keyword">identifier</span> f, P, p;
<span class="hljs-keyword">type</span> T1, T2;
<span class="hljs-title">@@</span>
<span class="hljs-deletion">- f&lt;P: T1&gt;(p: P) -&gt; T2</span>
<span class="hljs-addition">+ f(p: impl T1) -&gt; T2</span>
     { ... }
</code></pre>
<h2 id="current-status"><a class="header" href="#current-status">Current status</a></h2>
<p>Coccinelle for Rust is currently a prototype.  It relies on Rust Analyzer
for parsing and rustfmt for pretty printing.  It mainly supports matching
and transformation of expressions and types, but reasoning about control
flow is not yet supported.</p>
<h2 id="availability"><a class="header" href="#availability">Availability</a></h2>
<p><a href="https://gitlab.inria.fr/coccinelle/coccinelleforrust.git">Coccinelle for Rust</a></p>
<p><a href="https://lwn.net/Articles/991399/">LWN article from Kangregos 2024</a></p>
<p><a href="https://gitlab.inria.fr/coccinelle/coccinelleforrust/-/raw/ctl2/talks/lpc24.pdf?ref_type=heads">A recent talk about Coccinelle for Rust</a></p>
<h2 id="feedback-1"><a class="header" href="#feedback-1">Feedback</a></h2>
<p>Coccinelle for Rust relies on user feedback for its improvement.
Several bugs have been fixed thanks to helpful feedback from users.
If you are interested in using Coccinelle for Rust please feel free to
reach out to us at <a href="Coccinelle-for-Rust.html#contact">Contact</a> with your questions or feedback.</p>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<p>We would like to thank <a href="https://www.collabora.com">Collabora</a> for supporting
the development of Coccinelle for Rust.</p>
<h2 id="contact-1"><a class="header" href="#contact-1">Contact</a></h2>
<ul>
<li>Julia Lawall: <a href="mailto:Julia.Lawall@inria.fr">Julia.Lawall@inria.fr</a></li>
<li>Tathagata Roy: <a href="mailto:tathagata.roy1278@gmail.com">tathagata.roy1278@gmail.com</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustc_codegen_gcc"><a class="header" href="#rustc_codegen_gcc"><code>rustc_codegen_gcc</code></a></h1>
<p><a href="https://github.com/rust-lang/rustc_codegen_gcc"><code>rustc_codegen_gcc</code></a> is a GCC ahead-of-time codegen for rustc, meaning that it can be loaded by the existing rustc frontend, but benefits from GCC by having more architectures supported and having access to GCC’s optimizations.</p>
<p>Rust for Linux can be compiled with <code>rustc_codegen_gcc</code> which allows to have a GCC-compiled Linux kernel with Rust kernel modules compiled with GCC as well.</p>
<p><a href="https://blog.antoyo.xyz/">Blog with updates about the progress of the GCC codegen.</a></p>
<h2 id="building-rustc_codegen_gcc-and-the-sysroot"><a class="header" href="#building-rustc_codegen_gcc-and-the-sysroot">Building <code>rustc_codegen_gcc</code> and the sysroot</a></h2>
<p>Follow the build instructions <a href="https://github.com/rust-lang/rustc_codegen_gcc#quick-start">here</a>.</p>
<h2 id="building-rust-for-linux"><a class="header" href="#building-rust-for-linux">Building Rust for Linux</a></h2>
<p>Follow the <a href="https://docs.kernel.org/rust/quick-start.html">Rust for Linux Quick Start instructions</a> with a few changes as explained below.</p>
<p>First, disable <code>MITIGATION_RETPOLINE</code> in <code>menuconfig</code> at: Mitigations for CPU vulnerabilities -&gt; Avoid speculative indirect branches in kernel.</p>
<p>Since the GCC codegen might not work on every nightly version (that should soon be fixed now that we run some tests in the Rust CI), we're going to use <a href="https://github.com/rust-lang/rustc_codegen_gcc/blob/master/rust-toolchain">the same nightly version as the GCC codegen</a> instead of using the version recommended by Rust for Linux:</p>
<pre><code class="language-sh">rustup override set nightly-2023-10-21 # Adjust to the version used by the GCC codegen.
</code></pre>
<p>Now, you need to set some variables to build Rust for Linux with the GCC codegen (do not forget to adjust your path to <code>rustc_codegen_gcc</code>):</p>
<pre><code class="language-sh">make -j20 KRUSTFLAGS=&quot;-Zcodegen-backend=/path/to/rustc_codegen_gcc/target/debug/librustc_codegen_gcc.so&quot; \
    HOSTRUSTFLAGS=&quot;-Zcodegen-backend=/path/to/rustc_codegen_gcc/target/debug/librustc_codegen_gcc.so \
    --sysroot /path/to/rustc_codegen_gcc/build_sysroot/sysroot -Clto=no&quot;
</code></pre>
<h2 id="ci"><a class="header" href="#ci">CI</a></h2>
<p>We have a <a href="https://github.com/Rust-for-Linux/ci-rustc_codegen_gcc">repo</a> that runs some tests of Rust for Linux compiled with <code>rustc_codegen_gcc</code>.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>If that didn't build the Rust object files, run <code>make menuconfig</code> again and check if the &quot;Rust support&quot; is available.
It could be that you have <code>RUST_IS_AVAILABLE [=n]</code>.
In that case, run <code>make rustavailable</code> with the <code>KRUSTFLAGS</code> you used above.
That should give you the correct error, which could be one of those:</p>
<ul>
<li><code>libgccjit.so.0: cannot open shared object file: No such file or directory</code>
<ul>
<li>In this case, make sure you set <code>LD_LIBRARY_PATH</code> and <code>LIBRARY_PATH</code>.</li>
</ul>
</li>
<li><code>Source code for the 'core' standard library could not be found</code>
<ul>
<li>In this case, make sure you used a recent enough version of <code>rustc_codegen_gcc</code> (c6bc7ecd65046ee502118664f42637ca318cdfb5 or more recent should be good) that copies the source of the sysroot at the correct location.</li>
</ul>
</li>
</ul>
<h2 id="contact-2"><a class="header" href="#contact-2">Contact</a></h2>
<p>Please contact Antoni Boucher (antoyo) on
<a href="https://matrix.to/#/#rustc_codegen_gcc:matrix.org">Matrix</a> or post a message on <a href="https://rust-lang.zulipchat.com/#narrow/channel/386786-rustc-codegen-gcc">Zulip</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gccrs"><a class="header" href="#gccrs"><code>gccrs</code></a></h1>
<p><a href="https://github.com/rust-gcc/gccrs"><code>gccrs</code></a> is an alternative compiler for the Rust
programming language, developed from the ground up for the
<a href="https://gcc.gnu.org">GNU Compiler Collection (GCC)</a> project.</p>
<p>While <code>gccrs</code> is not yet able to compile Rust code, it is progressing fast — we are hoping we will be able to compile the Rust 1.49 <code>core</code> library in 2025 and the standard library with the GCC 16.1 release.</p>
<p>When <code>core</code> compiles properly, we will begin catching up to the Rust version used by Rust-for-Linux — in the hopes of being useful quickly!</p>
<p>You can follow the project's progress on <a href="https://rust-gcc.github.io">our blog</a>.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://gcc-rust.zulipchat.com">Zulip chat</a></li>
<li><a href="https://gcc.gnu.org/mailman/listinfo/gcc-rust">Mailing list</a></li>
<li><a href="https://github.com/rust-gcc">GitHub organization</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="amcc-qt2025-phy-driver"><a class="header" href="#amcc-qt2025-phy-driver">AMCC QT2025 PHY Driver</a></h1>
<p>The Rust AMCC QT2025 driver is for the Applied Micro Circuits Corporation (AMCC) QT2025 PHY (Physical Layer) device. This driver facilitates communication between the operating system and the QT2025 hardware, ensuring proper network functionality.</p>
<p>The driver was <a href="https://git.kernel.org/linus/fd3eaad826daf4774835599e264b216a30129c32">merged</a> into Linux kernel version v6.12-rc1 along with the improvements to the PHY abstraction that provides safe APIs for PHY drivers.</p>
<p>Both the Rust QT2025 driver and the MAC driver for Tehuti Networks' TN40xx chips have been tested using the Edimax EN-9320SFP+ 10G network adapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android-binder-driver"><a class="header" href="#android-binder-driver">Android Binder Driver</a></h1>
<p>This project is an effort to rewrite Android's Binder kernel driver in Rust.</p>
<p>The driver was <a href="https://git.kernel.org/linus/eafedbc7c050c44744fbdf80bdf3315e860b7513">merged</a>
into Linux kernel version v6.18-rc1.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Binder is one of the most security and performance critical components of Android.
Android isolates apps from each other and the system by assigning each app a
unique user ID (UID).  This is called &quot;application sandboxing&quot;, and is a fundamental
tenet of the <a href="https://arxiv.org/abs/1904.05572">Android Platform Security Model</a>.</p>
<p>The majority of inter-process communication (IPC) on Android goes through Binder.
Thus, memory unsafety vulnerabilities are especially critical when they happen in the
Binder driver.</p>
<h2 id="maintenance"><a class="header" href="#maintenance">Maintenance</a></h2>
<p>The Rust driver was originally authored by Wedson Almeida Filho, and is now maintained
by Alice Ryhl. The ongoing work will be part of the
<a href="https://source.android.com/">Android Open Source Project</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asix-phy-driver"><a class="header" href="#asix-phy-driver">ASIX PHY Driver</a></h1>
<p>The Rust ASIX driver is for ASIX Electronics' Ethernet PHY (Physical Layer) devices. This driver facilitates communication between the operating system and the ASIX AX887xx chips, ensuring proper network functionality.</p>
<p>The driver is the first Rust driver merged into the Linux kernel. It was <a href="https://git.kernel.org/linus/cbe0e415089636170aa6eb540ca4af5dc9842a60">merged</a> into Linux kernel version v6.8-rc1 along with a PHY abstraction that provides safe APIs for PHY drivers.</p>
<p>The ASIX driver is <a href="Rust-reference-drivers.html">a Rust reference driver</a>. It serves as a guide for developers. ASIX PHY chips are widely used in affordable 10/100M USB Ethernet adapters from various vendors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drm-panic-qr-code-generator"><a class="header" href="#drm-panic-qr-code-generator">DRM Panic QR code generator</a></h1>
<p>This is a simple QR code generator, to display the panic data as a QR code. It is specific to the DRM panic use case, and supports only some parts of the QR code specification.</p>
<h2 id="why-a-qr-code-in-a-panic-screen"><a class="header" href="#why-a-qr-code-in-a-panic-screen">Why a QR code in a panic screen?</a></h2>
<p>Kernel panic traces are usually displayed on the screen, but then it's hard to copy and paste them to a bug report, so that a developer can take a look, and fix the bug.</p>
<p>As QR code are now widespread, using that allows to easily copy and paste the panic traces in a bug report, which makes debugging much easier for both the user and the kernel developer.</p>
<p>The QR code has a better pixel density than text, that means you can put more debug data into a QR code, than you can see as text only on a standard monitor.</p>
<h2 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h2>
<p>This project was written in rust, because memory safety is critical in a panic handler.</p>
<p>The QR code encoder is self-contained and only uses the provided memory buffer, so there is no need to add complex bindings, and it was easy to merge it in the kernel.</p>
<p>For this particular case, I found the Rust code to be cleaner, and easier to read than the C equivalent, even if I'm much more experienced in C.</p>
<h2 id="availability-1"><a class="header" href="#availability-1">Availability</a></h2>
<p>The code was <a href="https://git.kernel.org/linus/cb5164ac43d0fc37ac6b45cabbc4d244068289ef">merged</a> into Linux kernel version v6.12-rc1. Arch Linux will enable it soon in its <a href="https://gitlab.archlinux.org/archlinux/packaging/packages/linux/-/commit/39947637f309b0862a383733d5acf7ae55122d10">kernel</a>.</p>
<h2 id="side-projects"><a class="header" href="#side-projects">Side projects</a></h2>
<p>An example web frontend to decode the panic data from the QR code: <a href="https://github.com/kdj0c/panic_report">https://github.com/kdj0c/panic_report</a>.</p>
<p>A few samples of a panic screen with a QR code are available here: <a href="https://github.com/kdj0c/panic_report/issues/1">https://github.com/kdj0c/panic_report/issues/1</a>.</p>
<p>You can test the same code in a standalone rust app (outside the kernel): <a href="https://gitlab.com/kdj0c/qr_panic">https://gitlab.com/kdj0c/qr_panic</a>.</p>
<p>I try to keep it up-to-date with the latest Linux kernel.</p>
<h2 id="maintenance-1"><a class="header" href="#maintenance-1">Maintenance</a></h2>
<p>The main author of the QR code generator is Jocelyn Falempe &lt;<a href="mailto:jfalempe@redhat.com">jfalempe@redhat.com</a>&gt;, with help from the Rust for Linux community.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nova-gpu-driver"><a class="header" href="#nova-gpu-driver">Nova GPU Driver</a></h1>
<p>Nova is a driver for GSP (GPU system processor) based Nvidia GPUs. It is
intended to become the successor of Nouveau as the mainline driver for Nvidia
(GSP) GPUs in Linux.</p>
<p>It will support all Nvidia GPUs beginning with the GeForce RTX20 (Turing family)
series and newer.</p>
<h2 id="contact-3"><a class="header" href="#contact-3">Contact</a></h2>
<p>Available communication channels are:</p>
<ul>
<li>The mailing list: nouveau@lists.freedesktop.org</li>
<li>IRC: #nouveau on OFTC</li>
<li><a href="https://rust-for-linux.zulipchat.com/#narrow/channel/509436-Nova">Zulip Chat</a></li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>The parts that are already in mainline Linux can be found in
<code>drivers/gpu/nova-core/</code> and <code>drivers/gpu/drm/nova/</code></p>
<p>Development currently takes place in
<a href="https://gitlab.freedesktop.org/drm/rust/kernel/-/tree/drm-rust-next">the drm-rust-next tree</a>
alongside other DRM Rust drivers, for easier collaboration and integration.
There's also <a href="https://gitlab.freedesktop.org/drm/nova">a standalone repo for the Nova driver</a>,
but it's currently unused. </p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<h3 id="why-a-new-driver"><a class="header" href="#why-a-new-driver">Why a new driver?</a></h3>
<p>Nouveau was, for the most part, designed for pre-GSP hardware. The driver exists
since ~2009 and its authors back in the day had to reverse engineer a lot about
the hardware's internals, resulting in a relatively difficult to maintain
codebase.</p>
<p>Moreover, Nouveau's maintainers concluded that a new driver, exclusively for
GSP hardware, would allow for significantly simplifying the driver design: Most
of the hardware internals that Nouveau had to reverse engineer reside in the
GSP firmware. Hereby, the GSP takes up the role of a hardware abstraction layer
which communicates with the host kernel through IPC. Thereby, a lot of the
stack's complexity is moved from the GPU driver into the GSP firmware.</p>
<p>This, in consequence, enables better maintainability. Another chance with a new
driver is to obtain active community participation from the very beginning.</p>
<h3 id="why-write-it-in-rust"><a class="header" href="#why-write-it-in-rust">Why write it in Rust?</a></h3>
<p>Besides Rust's built-in ownership and lifetime model, its powerful type system
allows us to avoid a large portion of a whole class of bugs (i.e. memory safety
bugs).</p>
<p>Additionally, the same features allow us to model APIs in a way that also
certain logic errors can be caught at compile time already.</p>
<p>Especially GPU drivers can benefit a lot from Rust's ownership and lifetime
model, given their highly concurrent and asynchronous design.</p>
<p>Since Nova is a new driver, written from scratch, it is an opportunity to try to
leverage the advantages of Rust and obtain a more reliable, maintainable driver.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p><img src="./nova-core-vm.png" alt="Nova Architecture with vGPUs" /></p>
<p>The overall GPU driver is split into two parts:</p>
<ol>
<li>&quot;Nova-Core&quot;, living in <code>drivers/gpu/nova-core/</code>. Nova-Core implements
the fundamental interaction with the hardware (through PCI etc.) and,
notably, boots up the GSP and interacts with it through a command queue.</li>
<li>&quot;Nova-DRM&quot; (the official name is actually just &quot;Nova&quot;, but to avoid
confusion developers usually call it &quot;Nova-DRM&quot;), living in
<code>drivers/gpu/drm/nova/</code>. This is the actual graphics driver,
implementing all the typical DRM interfaces for userspace.</li>
</ol>
<p>This split architecture allows for different drivers building on top of the
abstraction layer provided by Nova-Core. Besides Nova-DRM, for instance, a VFIO
driver to virtualize the GPU can be built on top of Nova-Core. Through this
driver Nova-Core can be used to instruct the GPU's firmware to spawn new PCI
virtual functions (through
<a href="https://docs.kernel.org/PCI/pci-iov-howto.html">SR-IOV</a>), representing virtual
GPUs. Those virtual functions (or vGPUs) can be used by virtual machines. Such
a virtual machine running Linux may run Nova-Core and Nova-DRM as conventional
GPU drivers on top of this vGPU.</p>
<p>A main advantage of this design is that the amount of software running on the
host (where crashes would be far more fatal than inside of a VM) is kept small,
which contributes to stability.</p>
<p>It is also possible to use Nova-Core + Nova-DRM on one physical machine (not
depicted in the diagram) in order to expose a DRM compatible uAPI to the host
userspace.</p>
<p>For more details about vGPUs, take a look at
<a href="https://lore.kernel.org/nouveau/20240922124951.1946072-1-zhiw@nvidia.com/">Zhi's announcement email</a>.</p>
<h2 id="status-and-contributing"><a class="header" href="#status-and-contributing">Status and Contributing</a></h2>
<p>The necessary Rust infrastructure has been progressing a lot. Current work now
focuses more on the actual driver. In case you want to contribute, take a look
at the
<a href="https://docs.kernel.org/gpu/nova/core/todo.html">NOVA TODO List</a>.</p>
<p>Don't hesitate reaching out on the aforementioned community channels.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-block-driver"><a class="header" href="#null-block-driver">Null Block Driver</a></h1>
<p>The Rust null block driver <code>rnull</code> is an effort to implement a drop in
replacement for <code>null_blk</code> in Rust.</p>
<p>A null block driver is a good opportunity to evaluate Rust bindings for the
block layer. It is a small and simple driver and thus should be simple to reason
about. Further, the null block driver is not usually deployed in production
environments. Thus, it should be fairly straight forward to review, and any
potential issues are not going to bring down any production workloads.</p>
<p>Being small and simple, the null block driver is a good place to introduce the
Linux kernel storage community to Rust. This will help prepare the community for
future Rust projects and facilitate a better maintenance process for these
projects.</p>
<p><a href="https://lore.kernel.org/all/87y1ofj5tt.fsf@metaspace.dk/">Statistics</a> from the
commit log of the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/block/null_blk?h=v6.1">C <code>null_blk</code>
driver</a>
(<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/block/null_blk_main.c?h=v6.1&amp;id=ea17fd354ca8afd3e8962a77236b1a9a59262fdd">before
move</a>)
show that the C null block driver has had a significant amount of memory safety
related problems in the past. 41% of fixes merged for the C null block driver
are fixes for memory safety issues. This makes the null block driver a good
candidate for rewriting in Rust.</p>
<p>The driver is implemented entirely in safe Rust, with all unsafe code fully
contained in the abstractions that wrap the C APIs.</p>
<p>Please note that the performance measurements on this page might be misleading
due to the results not being normally distributed. <a href="https://metaspace.github.io/2024/12/02/problems-in-benchmark-land.html">This
analysis</a>
has more details. We observe that issue is resovled for v6.14-rc5, but we are
monitoring the situation going forward.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>Implemented features:</p>
<ul>
<li><code>blk-mq</code> support</li>
<li>Direct completion</li>
<li>SoftIRQ completion</li>
<li>Timer completion</li>
<li>Read and write requests</li>
<li>Optional memory backing</li>
<li>Bio-based submission</li>
<li>NUMA support</li>
<li>Block size configuration</li>
<li>Multiple devices</li>
<li>Dynamic device creation/destruction</li>
<li>Queue count configuration</li>
<li>Per node hctx</li>
<li>Queue depth configuration</li>
<li>Discard operation support</li>
<li>Cache emulation</li>
<li>Bandwidth throttling</li>
<li>IO scheduler configuration</li>
<li>Blocking submission mode</li>
<li>Shared tags configuration (for &gt;1 device)</li>
<li>Bad block simulation</li>
</ul>
<p>Features available in the C <code>null_blk</code> driver that are currently not implemented
in this work:</p>
<ul>
<li>Zoned storage support</li>
<li>Poll queues</li>
</ul>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<ul>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull">Latest patches</a></li>
<li><a href="https://github.com/metaspace/linux/tree/null_block-RFC">Original RFC Patches</a></li>
<li><a href="https://lore.kernel.org/all/20230503090708.2524310-1-nmi@metaspace.dk/">Mailing List Post</a></li>
<li><a href="https://lore.kernel.org/all/20240611114551.228679-1-nmi@metaspace.dk/">Subset merged in v6.11-rc1</a></li>
</ul>
<h2 id="618-rc5-rebase-rnull-v618-rc5"><a class="header" href="#618-rc5-rebase-rnull-v618-rc5">6.18-rc5, Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.18-rc5"><code>rnull-v6.18-rc5</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.17.7</code>:</p>
<ul>
<li>Add bandwidth throttling</li>
<li>Add blocking queue mode</li>
<li>Add shared tags support</li>
<li>Add queue depth configuration option</li>
</ul>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<h4 id="setup"><a class="header" href="#setup">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.11</li>
</ul>
<h4 id="results"><a class="header" href="#results">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.18-rc5.svg" alt="" /></p>
<h5 id="sample-distribution"><a class="header" href="#sample-distribution">Sample Distribution</a></h5>
<ul>
<li>C left bounded by blue line.</li>
<li>Rust right bounded by orange line.</li>
</ul>
<p><img src="rnull/rnull-v6.18-rc5-density.svg" alt="" /></p>
<h2 id="617-rebase-rnull-v6177"><a class="header" href="#617-rebase-rnull-v6177">6.17 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.17.7"><code>rnull-v6.17.7</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.16</code>:</p>
<ul>
<li>Add discard support</li>
<li>Add no_sched support</li>
<li>Add badblocks emulation</li>
<li>Add volatile cache emulation</li>
</ul>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<h4 id="setup-1"><a class="header" href="#setup-1">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.11</li>
</ul>
<h4 id="results-1"><a class="header" href="#results-1">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.17.7.svg" alt="" /></p>
<h5 id="sample-distribution-1"><a class="header" href="#sample-distribution-1">Sample Distribution</a></h5>
<ul>
<li>C left bounded by blue line.</li>
<li>Rust right bounded by orange line.</li>
</ul>
<p><img src="rnull/rnull-v6.17.7-density.svg" alt="" /></p>
<h2 id="616-rebase-rnull-v616"><a class="header" href="#616-rebase-rnull-v616">6.16 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.16"><code>rnull-v6.16</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.15</code>:</p>
<ul>
<li>No changes</li>
</ul>
<h3 id="performance-2"><a class="header" href="#performance-2">Performance</a></h3>
<h4 id="setup-2"><a class="header" href="#setup-2">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.11</li>
</ul>
<h4 id="results-2"><a class="header" href="#results-2">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.16.svg" alt="" /></p>
<h5 id="sample-distribution-2"><a class="header" href="#sample-distribution-2">Sample Distribution</a></h5>
<ul>
<li>C left bounded by blue line.</li>
<li>Rust right bounded by orange line.</li>
</ul>
<p><img src="rnull/rnull-v6.16-density.svg" alt="" /></p>
<h2 id="615-rebase-rnull-v615"><a class="header" href="#615-rebase-rnull-v615">6.15 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.15"><code>rnull-v6.15</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.14</code>:</p>
<ul>
<li>No changes</li>
</ul>
<h3 id="performance-3"><a class="header" href="#performance-3">Performance</a></h3>
<h4 id="setup-3"><a class="header" href="#setup-3">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.11</li>
</ul>
<h4 id="results-3"><a class="header" href="#results-3">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.15.svg" alt="" /></p>
<h5 id="sample-distribution-3"><a class="header" href="#sample-distribution-3">Sample Distribution</a></h5>
<ul>
<li>C left bounded by blue line.</li>
<li>Rust right bounded by orange line.</li>
</ul>
<p><img src="rnull/rnull-v6.15-density.svg" alt="" /></p>
<h2 id="614-rc5-rebase-rnull-v614-rc5"><a class="header" href="#614-rc5-rebase-rnull-v614-rc5">6.14-rc5 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.14-rc5"><code>rnull-v6.14-rc5</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.13</code>:</p>
<ul>
<li>Change reference counting scheme for <code>Request</code>.</li>
<li>Move <code>rnull</code> driver to separate directory.</li>
<li>Rename <code>RawWriter</code> to <code>BufferWriter</code> and move it.</li>
<li>Enable configuration of <code>rnull</code> via <code>configfs</code>.
<ul>
<li>Enable dynamic createion/destruction of devices via <code>configfs</code>.</li>
</ul>
</li>
<li>Use <code>Owned</code> for rust managed <code>Page</code> objects.</li>
<li>Change segment iterator to prevent concurrent mutable access to pages.</li>
<li>Use <code>GFP_NOIO</code> flag for backing rnull pages.</li>
<li>Add <code>user_per_node_hctx</code> rnull config option.</li>
<li>Add NUMA home node rnull config option.</li>
<li>Add submit queue count rnull config option.</li>
<li>Fix a bug where unwritten bytes were not zeroed on read.</li>
<li>Properly handle IO requests that are not equal in size to one block.</li>
</ul>
<h3 id="performance-4"><a class="header" href="#performance-4">Performance</a></h3>
<h4 id="setup-4"><a class="header" href="#setup-4">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.11</li>
</ul>
<h4 id="results-4"><a class="header" href="#results-4">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.14-rc5.svg" alt="" /></p>
<h2 id="613-rebase-rnull-v613"><a class="header" href="#613-rebase-rnull-v613">6.13 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.13"><code>rnull-v6.13</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.12</code>:</p>
<ul>
<li>None</li>
</ul>
<h3 id="performance-5"><a class="header" href="#performance-5">Performance</a></h3>
<h4 id="setup-5"><a class="header" href="#setup-5">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h4 id="results-5"><a class="header" href="#results-5">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.13.svg" alt="" /></p>
<h2 id="612-rebase-rnull-v612"><a class="header" href="#612-rebase-rnull-v612">6.12 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.12"><code>rnull-v6.12</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.12-rc2</code>:</p>
<ul>
<li>None</li>
</ul>
<h3 id="performance-6"><a class="header" href="#performance-6">Performance</a></h3>
<h4 id="setup-6"><a class="header" href="#setup-6">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h4 id="results-6"><a class="header" href="#results-6">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.12.svg" alt="" /></p>
<h2 id="612-rc2-rebase-rnull-v612-rc2"><a class="header" href="#612-rc2-rebase-rnull-v612-rc2">6.12-rc2 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.12-rc2"><code>rnull-v6.12-rc2</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.11</code>:</p>
<ul>
<li>Make <code>QueueData</code> references pinned.</li>
</ul>
<h3 id="performance-7"><a class="header" href="#performance-7">Performance</a></h3>
<h4 id="setup-7"><a class="header" href="#setup-7">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h4 id="results-7"><a class="header" href="#results-7">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.12-rc2.svg" alt="" /></p>
<h2 id="611-rebase-rnull-v611"><a class="header" href="#611-rebase-rnull-v611">6.11 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.11"><code>rnull-v6.11</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.10</code>:</p>
<ul>
<li>None.</li>
</ul>
<h3 id="performance-8"><a class="header" href="#performance-8">Performance</a></h3>
<h4 id="setup-8"><a class="header" href="#setup-8">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h4 id="results-8"><a class="header" href="#results-8">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.11.svg" alt="" /></p>
<h2 id="611-rc2-rebase-rnull-v611-rc2"><a class="header" href="#611-rc2-rebase-rnull-v611-rc2">6.11-rc2 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.11-rc2"><code>rnull-v6.11-rc2</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.10</code>:</p>
<ul>
<li>Base abstractions merged upstream 🥳</li>
<li>Use atomic queue limits C API for setting queue limits.</li>
</ul>
<h3 id="performance-9"><a class="header" href="#performance-9">Performance</a></h3>
<h4 id="setup-9"><a class="header" href="#setup-9">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h4 id="results-9"><a class="header" href="#results-9">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.11-rc2.svg" alt="" /></p>
<h2 id="610-rebase-rnull-v610"><a class="header" href="#610-rebase-rnull-v610">6.10 Rebase (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnull-v6.10"><code>rnull-v6.10</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.10-rc3</code>:</p>
<ul>
<li>None</li>
</ul>
<h3 id="performance-10"><a class="header" href="#performance-10">Performance</a></h3>
<h4 id="setup-10"><a class="header" href="#setup-10">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h4 id="results-10"><a class="header" href="#results-10">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.10.svg" alt="" /></p>
<h2 id="610-rc3-rebase-rnull-v610-rc3"><a class="header" href="#610-rc3-rebase-rnull-v610-rc3">6.10-rc3 Rebase (<a href="https://github.com/metaspace/linux/tree/rnull-v6.10-rc3"><code>rnull-v6.10-rc3</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.9</code>:</p>
<ul>
<li>Add <code>ForeignBorrowed</code>.</li>
<li>Move <code>GenDisk</code> to a builder pattern instead of typestate pattern.</li>
<li>Move block size validation from driver to abstractions.</li>
<li>Pin <code>NullBlkModuel</code>.</li>
<li>Refactor <code>Request::try_set_end</code>.</li>
<li>Rewrite atomic functions in terms of <code>core</code> library functions.</li>
<li>Fix a bug in timer completions where an offset was not calculated correctly.</li>
<li>Refactor <code>TagSet</code> initialization in terms of <code>core::mem::zeroed()</code> instead of <code>Opaque::try_ffi_init</code></li>
</ul>
<h3 id="performance-11"><a class="header" href="#performance-11">Performance</a></h3>
<h4 id="setup-11"><a class="header" href="#setup-11">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h4 id="results-11"><a class="header" href="#results-11">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.10-rc3.svg" alt="" /></p>
<h2 id="69-rebase-rnull-v69"><a class="header" href="#69-rebase-rnull-v69">6.9 Rebase (<a href="https://github.com/metaspace/linux/tree/rnull-v6.9"><code>rnull-v6.9</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.8</code>:</p>
<ul>
<li>Do not rely on C refcounting of <code>Request</code></li>
<li>Use <code>ARef</code> to track <code>Request</code> lifetime</li>
<li>Use <code>Page</code> instead of <code>Folio</code> to track memory for memory backed mode</li>
<li>Use typestate pattern to track state of <code>GenDisk</code></li>
<li>Panic when requests cannot be completed</li>
<li>Remove associated type <code>RequestDataInit</code> and use return position impl trait instead</li>
<li>Call <code>Request::start</code> implicitly</li>
<li>Split helper function C file</li>
</ul>
<h3 id="performance-12"><a class="header" href="#performance-12">Performance</a></h3>
<h4 id="setup-12"><a class="header" href="#setup-12">Setup</a></h4>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h4 id="results-12"><a class="header" href="#results-12">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>5 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.9.svg" alt="" /></p>
<h2 id="68-rebase-rnull-v68"><a class="header" href="#68-rebase-rnull-v68">6.8 Rebase (<a href="https://github.com/metaspace/linux/tree/rnull-v6.8"><code>rnull-v6.8</code></a>)</a></h2>
<p>Changes from <code>rnull-v6.8-rc6</code>:</p>
<ul>
<li>Slight refactoring of patch order</li>
</ul>
<h3 id="performance-13"><a class="header" href="#performance-13">Performance</a></h3>
<h4 id="setup-13"><a class="header" href="#setup-13">Setup</a></h4>
<ul>
<li>12th Gen Intel(R) Core(TM) i5-12600</li>
<li>32 GB DRAM</li>
<li>Debian Bullseye userspace</li>
</ul>
<h4 id="results-13"><a class="header" href="#results-13">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>5 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.8.svg" alt="" /></p>
<h2 id="68-rc6-rebase-rnull-v68-rc6"><a class="header" href="#68-rc6-rebase-rnull-v68-rc6">6.8-rc6 Rebase (<a href="https://github.com/metaspace/linux/tree/rnull-v6.8-rc6"><code>rnull-v6.8-rc6</code></a>)</a></h2>
<p>Changes from <code>rnull-6.8</code>:</p>
<ul>
<li>Change lock alignment mechanics</li>
<li>Apply reference counting to <code>Request</code></li>
<li>Drop some inline directives</li>
</ul>
<h3 id="performance-14"><a class="header" href="#performance-14">Performance</a></h3>
<h4 id="setup-14"><a class="header" href="#setup-14">Setup</a></h4>
<ul>
<li>12th Gen Intel(R) Core(TM) i5-12600</li>
<li>32 GB DRAM</li>
<li>Debian Bullseye userspace</li>
</ul>
<h4 id="results-14"><a class="header" href="#results-14">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>5 samples for each configuration</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-v6.8-rc6.svg" alt="" /></p>
<h2 id="67-rebase-rnull-67"><a class="header" href="#67-rebase-rnull-67">6.7 Rebase (<a href="https://github.com/metaspace/linux/tree/rnull-6.7"><code>rnull-6.7</code></a>)</a></h2>
<p>Changes from null_blk-6.6:</p>
<ul>
<li>Move to <code>Folio</code> for memory backing instead of <code>Page</code></li>
<li>Move to <code>XArray</code> for memory backing instead of <code>RaddixTree</code></li>
</ul>
<h3 id="performance-15"><a class="header" href="#performance-15">Performance</a></h3>
<h4 id="setup-15"><a class="header" href="#setup-15">Setup</a></h4>
<ul>
<li>12th Gen Intel(R) Core(TM) i5-12600</li>
<li>32 GB DRAM</li>
<li>Debian Bullseye userspace</li>
</ul>
<h4 id="results-15"><a class="header" href="#results-15">Results</a></h4>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/rnull-6.7.svg" alt="" /></p>
<h2 id="performance-september-2023-null_blk-66"><a class="header" href="#performance-september-2023-null_blk-66">Performance September 2023 (<a href="https://github.com/metaspace/linux/tree/null_blk-6.6"><code>null_blk-6.6</code></a>)</a></h2>
<h3 id="setup-16"><a class="header" href="#setup-16">Setup</a></h3>
<ul>
<li>12th Gen Intel(R) Core(TM) i5-12600</li>
<li>32 GB DRAM</li>
<li>1x INTEL MEMPEK1W016GA (PCIe 3.0 x2)</li>
<li>Debian Bullseye userspace</li>
</ul>
<h3 id="results-16"><a class="header" href="#results-16">Results</a></h3>
<ul>
<li>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code></li>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnull/null_blk-6.6.svg" alt="" /></p>
<h2 id="performance-september-2023"><a class="header" href="#performance-september-2023">Performance September 2023</a></h2>
<h3 id="setup-17"><a class="header" href="#setup-17">Setup</a></h3>
<ul>
<li>12th Gen Intel(R) Core(TM) i5-12600</li>
<li>32 GB DRAM</li>
<li>1x INTEL MEMPEK1W016GA (PCIe 3.0 x2)</li>
<li>Debian Bullseye userspace</li>
</ul>
<h3 id="results-17"><a class="header" href="#results-17">Results</a></h3>
<p>In most cases there is less than 2% difference between the Rust and C drivers.</p>
<p><img src="./rnull/read-iops.svg" alt="" />
<img src="./rnull/write-iops.svg" alt="" />
<img src="./rnull/randread-iops.svg" alt="" />
<img src="./rnull/randwrite-iops.svg" alt="" />
<img src="./rnull/readwrite-iops.svg" alt="" />
<img src="./rnull/randrw-iops.svg" alt="" /></p>
<h2 id="contact-4"><a class="header" href="#contact-4">Contact</a></h2>
<p>Please contact Andreas Hindborg through
<a href="Contact.html#zulip-chat">Zulip</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tyr-gpu-driver"><a class="header" href="#tyr-gpu-driver">Tyr GPU Driver</a></h1>
<h2 id="what-is-tyr"><a class="header" href="#what-is-tyr">What is Tyr?</a></h2>
<p>Tyr is a new Rust-based DRM driver for CSF-based Arm Mali GPUs. It is a port of
Panthor — a driver written in C for the same hardware — and written as a joint
effort between Collabora, Arm and Google engineers.</p>
<p>Tyr aims to eventually implement the same userspace API offered by Panthor for
compatibility reasons, so that it can be used as a drop-in replacement in our
Vulkan driver, called
<a href="https://gitlab.freedesktop.org/mesa/mesa/-/tree/main/src/panfrost/vulkan?ref_type=heads">PanVK</a>.
In any case, we foresee Panthor being used — and of course supported — for a
relatively long time, as it is a mature driver with a large adoption in the
ecosystem. It will probably take a couple of years for Tyr to fully pick up.</p>
<h2 id="where-is-tyr-developed"><a class="header" href="#where-is-tyr-developed">Where is Tyr developed?</a></h2>
<p>Tyr is developed both upstream and downstream.</p>
<h3 id="upstream"><a class="header" href="#upstream">Upstream</a></h3>
<p>The initial skeleton of the Tyr driver is now <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/tyr">upstream</a>. Submissions against
the upstream Tyr driver should go to the <a href="https://lore.kernel.org/dri-devel/"><code>dri-devel</code></a>
and <a href="https://lore.kernel.org/rust-for-linux/"><code>rust-for-linux</code></a> mailing lists. If the
submission is larger and/or needs to be pre-reviewed, open a merge request
against the
<a href="https://gitlab.freedesktop.org/panfrost/linux/-/tree/tyr-for-upstream"><code>tyr-for-upstream</code></a>
branch in the <a href="https://gitlab.freedesktop.org/panfrost/linux"><code>panfrost/linux</code></a>
repository.</p>
<h3 id="downstream"><a class="header" href="#downstream">Downstream</a></h3>
<p>A more complete implementation of the Tyr driver is also available in the
<a href="https://gitlab.freedesktop.org/panfrost/linux/-/tree/tyr-dev"><code>tyr-dev</code></a> branch.
Make submissions against the downstream Tyr driver by opening a merge request
against <code>tyr-dev</code>. It's expected that <code>tyr-dev</code> will be significantly
refactored before upstreaming.</p>
<p>This split is unfortunately necessary as we do not have the required
infrastructure in upstream yet, although our plan is to eventually migrate to
an upstream-only development model once this changes.</p>
<p>We go into more details about why we chose to develop Tyr this way on our
series of <a href="https://www.collabora.com/news-and-blog/news-and-events/introducing-tyr-a-new-rust-drm-driver.html">blog
posts</a>
at <a href="https://www.collabora.com/news-and-blog/">Collabora's blog</a>. Anyone willing
to get acquainted with Mali's open source stack should refer to that, as we
will be covering the whole infrastructure from a simple Vulkan application to
the actual GPU hardware in Mali's CSF architecture. We will also cover the
various components needed to write a driver, as well as the status of the
abstractions needed to interact with them from Rust code.</p>
<p>As it currently stands, our downstream branch can be used to test the
abstractions that are still being developed. It makes sure that we can write a
functional driver with the abstractions that are currently being proposed.</p>
<h2 id="what-is-the-current-status-of-the-driver"><a class="header" href="#what-is-the-current-status-of-the-driver">What is the current status of the driver?</a></h2>
<p>The current upstream driver can power up the GPU and probe the device on an
RK3588 system-on-chip. This lets us read a few sections of ROM in the GPU,
which in turn lets us provide this information to userspace by means of a
<code>DRM_IOCTL_PANTHOR_DEV_QUERY</code> call.</p>
<p>This is all that can be done for now in upstream code, at least until the Micro
Controller Unit can be made to work.</p>
<p>Our downstream branch (<code>tyr-dev</code>) provides a full, working prototype that can run GNOME, Weston, and full-screen 3D games like SuperTuxKart: see <a href="https://www.collabora.com/news-and-blog/news-and-events/racing-karts-on-a-rust-gpu-kernel-driver.html">Racing karts on a Rust GPU kernel driver</a>.</p>
<h2 id="can-i-try-it-out"><a class="header" href="#can-i-try-it-out">Can I try it out?</a></h2>
<p>Anyone with a RK3588 SoC can test Tyr, but the driver is not capable of
replacing Panthor yet. A good candidate device is Radxa's
<a href="https://radxa.com/products/rock5/5b/">ROCK 5B</a> Single Board Computer.</p>
<p>A good starting point is to use the Tyr driver to run the Panthor <a href="https://gitlab.freedesktop.org/drm/igt-gpu-tools/-/tree/master/tests/panthor">IGT
tests</a>.
While only a subset of the tests pass on the upstream code for the reasons
highlighted above, they should all pass if run on <code>tyr-dev</code>.</p>
<p>Note that Mali GPUs are found in a vast array of devices, and that we will
support more hardware as we progress in the implementation.</p>
<h2 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h2>
<p>Tyr is open-source software, and as such, anyone interested in its development
can check our <a href="https://gitlab.freedesktop.org/panfrost/linux/-/issues/?label_name%5B%5D=tyr">issue
board</a>.
We will be posting good starting tasks at a future point.</p>
<p>To work on any given task, assign it to yourself and follow up with a merge
request against <code>tyr-for-upstream</code> (for patches targeting the upstream driver)
or <code>tyr-dev</code> (for work in the downstream staging branch).</p>
<p>Please also write the IGT tests needed to ensure that your code works.</p>
<p>Happy hacking!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android-ashmem"><a class="header" href="#android-ashmem">Android <code>ashmem</code></a></h1>
<p><a href="https://android.googlesource.com/kernel/common/+/refs/heads/android16-6.12/drivers/staging/android/ashmem_rust.rs"><code>ashmem</code></a> (Anonymous Shared Memory Subsystem for Android) is a new shared memory allocator, similar to POSIX SHM but with different behavior and sporting a simpler file-based API.</p>
<p>It is, in theory, a good memory allocator for low-memory devices, because it can discard shared memory units when under memory pressure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-agx-gpu-driver"><a class="header" href="#apple-agx-gpu-driver">Apple AGX GPU driver</a></h1>
<p>As part of the <a href="https://asahilinux.org/about/">Asahi Linux</a> project, the Apple
AGX GPU driver has been implemented in Rust for the Linux kernel, along with
creating DRM bindings and associated userspace pieces.</p>
<p>The driver lives <a href="https://github.com/AsahiLinux/linux/tree/bits/210-gpu">here</a>.
The current development team is:</p>
<ul>
<li><a href="https://social.treehouse.systems/@alyssa">Alyssa Rosenzweig</a> is writing
the OpenGL driver and compiler.</li>
<li><a href="https://vt.social/@lina">Asahi Lina</a> is writing the kernel driver and
helping with OpenGL.</li>
<li><a href="https://mastodon.social/@dougall">Dougall Johnson</a> is reverse-engineering
the instruction set with Alyssa.</li>
<li><a href="https://tech.lgbt/@ella">Ella Stanforth</a> is working on a Vulkan driver.</li>
</ul>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://asahilinux.org/2022/12/gpu-drivers-now-in-asahi-linux/">Apple GPU drivers now in Asahi Linux</a></li>
<li><a href="https://asahilinux.org/2022/11/tales-of-the-m1-gpu/">Tales of the M1 GPU</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nvme-driver"><a class="header" href="#nvme-driver">NVMe Driver</a></h1>
<p>The Rust NVMe driver is an effort to implement a PCI NVMe driver in safe Rust
for use in the Linux Kernel. The purpose of the driver is to provide a vehicle
for development of safe Rust abstractions and to prove feasibility of Rust as an
implementation language for high performance device drivers.</p>
<p>The Linux Rust NVMe driver lives
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnvme">here</a>.
This branch is routinely rebased on upstream Linux releases. Please be aware
that the <code>rnvme</code> branch is force pushed without notice. The version based on the
deprecated <code>rust</code> branch is available
<a href="https://github.com/metaspace/linux/tree/nvme-rust">here</a>.</p>
<p>The Rust NVMe driver was originally
authored by Wedson Almeida Filho and is now maintained by Andreas Hindborg
(Samsung).</p>
<p>The driver is not currently suitable for general use.</p>
<h2 id="resources-2"><a class="header" href="#resources-2">Resources</a></h2>
<ul>
<li>LPC 2022
<a href="https://lpc.events/event/16/contributions/1180/attachments/1017/1961/deck.pdf">slides</a>
and <a href="https://lpc.events/event/16/contributions/1180/attachments/1017/2249/go">video</a></li>
</ul>
<h2 id="615-rebase-performance-rnvme-v615"><a class="header" href="#615-rebase-performance-rnvme-v615">6.15 Rebase Performance (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnvme-v6.15"><code>rnvme-v6.15</code></a>)</a></h2>
<h3 id="setup-18"><a class="header" href="#setup-18">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.11</li>
</ul>
<h3 id="results-18"><a class="header" href="#results-18">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.15-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.15-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="614-rc5-rebase-performance-rnvme-v614-rc5"><a class="header" href="#614-rc5-rebase-performance-rnvme-v614-rc5">6.14-rc5 Rebase Performance (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnvme-v6.14-rc5"><code>rnvme-v6.14-rc5</code></a>)</a></h2>
<h3 id="setup-19"><a class="header" href="#setup-19">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.11</li>
</ul>
<h3 id="results-19"><a class="header" href="#results-19">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.14-rc5-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.14-rc5-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="613-rebase-performance-rnvme-v613"><a class="header" href="#613-rebase-performance-rnvme-v613">6.13 Rebase Performance (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnvme-v6.13"><code>rnvme-v6.13</code></a>)</a></h2>
<h3 id="setup-20"><a class="header" href="#setup-20">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.11</li>
</ul>
<h3 id="results-20"><a class="header" href="#results-20">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.13-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.13-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="612-rebase-performance-rnvme-v612"><a class="header" href="#612-rebase-performance-rnvme-v612">6.12 Rebase Performance (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnvme-v6.12"><code>rnvme-v6.12</code></a>)</a></h2>
<h3 id="setup-21"><a class="header" href="#setup-21">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.04</li>
</ul>
<h3 id="results-21"><a class="header" href="#results-21">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.12-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.12-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="612-rc2-rebase-performance-rnvme-v612-rc2"><a class="header" href="#612-rc2-rebase-performance-rnvme-v612-rc2">6.12-rc2 Rebase Performance (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnvme-v6.12-rc2"><code>rnvme-v6.12-rc2</code></a>)</a></h2>
<h3 id="setup-22"><a class="header" href="#setup-22">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h3 id="results-22"><a class="header" href="#results-22">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.12-rc2-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.12-rc2-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="611-rebase-performance-rnvme-v611"><a class="header" href="#611-rebase-performance-rnvme-v611">6.11 Rebase Performance (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnvme-v6.11"><code>rnvme-v6.11</code></a>)</a></h2>
<h3 id="setup-23"><a class="header" href="#setup-23">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h3 id="results-23"><a class="header" href="#results-23">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.11-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.11-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="611-rc2-rebase-performance-rnvme-v611-rc2"><a class="header" href="#611-rc2-rebase-performance-rnvme-v611-rc2">6.11-rc2 Rebase Performance (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnvme-v6.11-rc2"><code>rnvme-v6.11-rc2</code></a>)</a></h2>
<h3 id="setup-24"><a class="header" href="#setup-24">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h3 id="results-24"><a class="header" href="#results-24">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.11-rc2-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.11-rc2-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="610-rebase-performance-rnvme-v610"><a class="header" href="#610-rebase-performance-rnvme-v610">6.10 Rebase Performance (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/a.hindborg/linux.git/log/?h=rnvme-v6.10"><code>rnvme-v6.10</code></a>)</a></h2>
<h3 id="setup-25"><a class="header" href="#setup-25">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h3 id="results-25"><a class="header" href="#results-25">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.10-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.10-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="610-rc5-rebase-performance-rnvme-v610-rc5"><a class="header" href="#610-rc5-rebase-performance-rnvme-v610-rc5">6.10-rc5 Rebase Performance (<a href="https://github.com/metaspace/linux/tree/rnvme-v6.10-rc5"><code>rnvme-v6.10-rc5</code></a>)</a></h2>
<h3 id="setup-26"><a class="header" href="#setup-26">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h3 id="results-26"><a class="header" href="#results-26">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.10-rc5-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.10-rc5-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="69-rebase-performance-rnvme-v69"><a class="header" href="#69-rebase-performance-rnvme-v69">6.9 Rebase Performance (<a href="https://github.com/metaspace/linux/tree/rnvme-v6.9"><code>rnvme-v6.9</code></a>)</a></h2>
<h3 id="setup-27"><a class="header" href="#setup-27">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 24.05</li>
</ul>
<h3 id="results-27"><a class="header" href="#results-27">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.9-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.9-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="68-rebase-performance-rnvme-v68"><a class="header" href="#68-rebase-performance-rnvme-v68">6.8 Rebase Performance (<a href="https://github.com/metaspace/linux/tree/rnvme-v6.8"><code>rnvme-v6.8</code></a>)</a></h2>
<h3 id="setup-28"><a class="header" href="#setup-28">Setup</a></h3>
<ul>
<li>AMD Ryzen 5 7600</li>
<li>32 GB 4800 MT/s DDR5 on one channel</li>
<li>1x Samsung 990 Pro 1TB (PCIe 4.0 x4 16 GT/S)</li>
<li>NixOS 23.11</li>
</ul>
<h3 id="results-28"><a class="header" href="#results-28">Results</a></h3>
<ul>
<li>40 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P95 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-v6.8-absolute.svg" alt="" /></p>
<p><img src="rnvme/nvme-v6.8-relative.svg" alt="" /></p>
<p>The graph shows
<math>
<mfrac>
<mrow>
<mi>R</mi>
<mo>-</mo>
<mi>C</mi>
</mrow>
<mrow>
<mi>C</mi>
</mrow>
</mfrac>
</math>
where C is IO/s for the C driver and R is IO/s for the Rust driver. Thus, negative
means the C driver is faster while positive means the Rust driver is faster.</p>
<h2 id="67-rebase-performance-nvme-67"><a class="header" href="#67-rebase-performance-nvme-67">6.7 Rebase Performance (<a href="https://github.com/metaspace/linux/tree/nvme-6.7"><code>nvme-6.7</code></a>)</a></h2>
<h3 id="setup-29"><a class="header" href="#setup-29">Setup</a></h3>
<ul>
<li>12th Gen Intel(R) Core(TM) i5-12600</li>
<li>32 GB DRAM</li>
<li>1x INTEL MEMPEK1W016GA (PCIe 3.0 x2)</li>
<li>Debian Bullseye userspace</li>
<li>LTO results are enabled by a build system patch (a hack) that was not yet published.</li>
</ul>
<h3 id="results-29"><a class="header" href="#results-29">Results</a></h3>
<ul>
<li>30 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P99 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-all-6.7.svg" alt="" /></p>
<h4 id="difference-relative"><a class="header" href="#difference-relative">Difference Relative</a></h4>
<p>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code>'</p>
<p><img src="rnvme/nvme-diff-relative-6.7.svg" alt="" /></p>
<h2 id="performance-november-2023-nvme-66"><a class="header" href="#performance-november-2023-nvme-66">Performance November 2023 (<a href="https://github.com/metaspace/linux/tree/nvme-6.6"><code>nvme-6.6</code></a>)</a></h2>
<h3 id="setup-30"><a class="header" href="#setup-30">Setup</a></h3>
<ul>
<li>12th Gen Intel(R) Core(TM) i5-12600</li>
<li>32 GB DRAM</li>
<li>1x INTEL MEMPEK1W016GA (PCIe 3.0 x2)</li>
<li>Debian Bullseye userspace</li>
<li>LTO results are enabled by a build system patch (a hack) that was not yet published.</li>
</ul>
<h3 id="results-30"><a class="header" href="#results-30">Results</a></h3>
<ul>
<li>30 samples</li>
<li>Difference of means modeled with t-distribution</li>
<li>P99 confidence intervals</li>
</ul>
<p><img src="rnvme/nvme-all-6.6.svg" alt="" /></p>
<h4 id="difference"><a class="header" href="#difference">Difference</a></h4>
<p><img src="rnvme/nvme-diff-6.6.svg" alt="" /></p>
<h4 id="difference-relative-1"><a class="header" href="#difference-relative-1">Difference Relative</a></h4>
<p>Plot shows <code>(mean_iops_r - mean_iops_c) / mean_iops_c</code>'</p>
<p><img src="rnvme/nvme-diff-relative-6.6.svg" alt="" /></p>
<h2 id="performance-september-2023-1"><a class="header" href="#performance-september-2023-1">Performance September 2023</a></h2>
<p>The driver was
<a href="https://github.com/metaspace/linux/tree/7353a81d566510080f91099b1a2b31895c716c9d">rebased</a>
on top of
<a href="https://github.com/Rust-for-Linux/linux/commit/37152d4a7c6400a4250134e601eca8be1a2bbc16"><code>rust-next</code></a>
PR for 6.6 in September 2023.</p>
<h3 id="setup-31"><a class="header" href="#setup-31">Setup</a></h3>
<ul>
<li>12th Gen Intel(R) Core(TM) i5-12600</li>
<li>32 GB DRAM</li>
<li>1x INTEL MEMPEK1W016GA (PCIe 3.0 x2)</li>
<li>Debian Bullseye userspace</li>
</ul>
<h3 id="results-31"><a class="header" href="#results-31">Results</a></h3>
<p><img src="./rnvme/nvme-512-sep23.svg" alt="iops-512" />
<img src="./rnvme/nvme-all-sep23.svg" alt="iops-all" /></p>
<h2 id="performance-january-2023"><a class="header" href="#performance-january-2023">Performance January 2023</a></h2>
<p>Performance evaluation as of January 2023.</p>
<h3 id="setup-32"><a class="header" href="#setup-32">Setup</a></h3>
<ul>
<li>Dell PowerEdge R6525</li>
<li>1 CPU socket populated - EPYC 7313, 16 cores</li>
<li>128 GB DRAM</li>
<li>3x P5800x 16GT/s x4 7.88 GB/s (PCIe 4)</li>
<li>Debian bullseye (linux 5.19.0+)</li>
</ul>
<h3 id="results-32"><a class="header" href="#results-32">Results</a></h3>
<p><img src="./rnvme/iops-jan23.svg" alt="iops" />
<img src="./rnvme/relative-jan23.svg" alt="relative" /></p>
<h3 id="analysis"><a class="header" href="#analysis">Analysis</a></h3>
<p>For 4 KiB block size, the Rust NVMe driver performs similar to the C driver. For
this configuration the target drive is bandwidth limited.</p>
<p>For 512 B block size, the C driver outperforms the Rust driver by up to 6%. In
this configuration the drive is not bandwidth limited, but the benchmark becomes
compute limited. The Rust driver has a higher overhead and thus performs worse.</p>
<h2 id="work-items"><a class="header" href="#work-items">Work Items</a></h2>
<ul>
<li>Remove all unsafe code from the driver</li>
<li>Support device removal</li>
<li>Verify functionality by executing <code>blktests</code> and <code>xfstests</code> in CI</li>
<li>Add sys-fs nodes to allow use of <code>nvme-cli</code> with Rust NVMe driver</li>
<li>Support more kernel configurations by deferring initialization to a task queue</li>
<li>Improve performance of Rust NVMe driver</li>
</ul>
<h2 id="contact-5"><a class="header" href="#contact-5">Contact</a></h2>
<p>Please contact Andreas Hindborg through
<a href="Contact.html#zulip-chat">Zulip</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="puzzlefs-filesystem-driver"><a class="header" href="#puzzlefs-filesystem-driver">PuzzleFS filesystem driver</a></h1>
<p><a href="https://github.com/project-machine/puzzlefs">PuzzleFS</a> is a container
filesystem designed to address the limitations of the existing OCI format. The
main goals of the project are reduced duplication, reproducible image builds,
direct mounting support and memory safety guarantees, some inspired by the
<a href="https://hackmd.io/@cyphar/ociv2-brainstorm">OCIv2 design document</a>.</p>
<p>Reduced duplication is achieved using the content defined chunking algorithm
FastCDC. This implementation allows chunks to be shared among layers. Building
a new layer starting from an existing one allows reusing most of the chunks.</p>
<p>Another goal of the project is reproducible image builds, which is achieved by
defining a canonical representation of the image format. Direct mounting
support is a key feature of puzzlefs and, together with fs-verity, it provides
data integrity.</p>
<p>Lastly, memory safety is critical to puzzlefs, leading to the decision to
implement it in Rust. Another goal is to share the same code between user space
and kernel space in order to provide one secure implementation.</p>
<h2 id="resources-3"><a class="header" href="#resources-3">Resources</a></h2>
<ul>
<li><a href="https://github.com/project-machine/puzzlefs">PuzzleFS main repository</a></li>
<li><a href="https://github.com/ariel-miculas/linux/tree/puzzlefs">PuzzleFS kernel branch</a></li>
<li><a href="https://github.com/project-machine/puzzlefs/issues/78">Issue tracking the development of the kernel driver</a></li>
<li><a href="https://osseu2023.sched.com/event/b98e711a56261b4a892b5fdcdc29ca73">Talk at Open Source Summit Europe</a></li>
<li><a href="https://kangrejos.com/2023/PuzzleFS.pdf">Kangrejos slides</a></li>
<li><a href="https://lwn.net/Articles/945320/">LWN article</a></li>
</ul>
<h2 id="maintenance-2"><a class="header" href="#maintenance-2">Maintenance</a></h2>
<p>The PuzzleFS driver is maintained by Ariel Miculas. Contact him at
<a href="mailto:amiculas@cisco.com">amiculas@cisco.com</a> or through
<a href="Contact.html#zulip-chat">Zulip</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
